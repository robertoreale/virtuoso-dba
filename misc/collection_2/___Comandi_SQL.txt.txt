expdp 
select vp.spid PID, vs.SID SID, vs.serial# SERIAL#, vs.program PROG , vs.osuser OSUSER, vs.machine MACHINE
from v$session vs, v$process vp
where vs.paddr = vp.addr
and vs.sid = 105
/



___________ flashback table ____

From: Alferi, Carmelo [mailto:carmelo.alferi@hp.com] 
Sent: venerdì 25 marzo 2011 7.10
To: staff-dba
Cc: AM CORINTO; Badocchi Marco
Subject: errore Corinto

Questa notte la procedura dei recuperi ha restituito il seguente errore:

ORA-04063: package body "STCR_APPPRD.STCRPKG_MX90_UTILITY" has errors
ORA-06508: PL/SQL: could not find program unit being called:
"STCR_APPPRD.STCRPKG_MX90_UTILITY"
ORA-06512: at line 2




flashback table tst to before drop;

STCRMTB161P
STCRMTB162P
STCRMTB111P
STCRMTB081P
STCRMTB009P
STCRMTB573P

STCRMTB041P

flashback table STCRMTB161P to before drop;
flashback table STCRMTB162P to before drop;
flashback table STCRMTB111P to before drop;
flashback table STCRMTB081P to before drop;
flashback table STCRMTB009P to before drop;
flashback table STCRMTB573P to before drop;




__________ DBA_HIST index _____
select SQL_ID,SEARCH_COLUMNS,SQL_TEXT from dba_hist_sqltext
where SQL_ID in ( 
select
    distinct(sql_id)
from
   dba_hist_sql_plan
natural join
   dba_hist_snapshot
natural join
   dba_hist_sqlstat
where object_name like 'STCRMTB010P_DBA1');

-- plan
set lines 155
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a30
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id, ss.instance_number node, begin_interval_time, sql_id, plan_hash_value,
nvl(executions_delta,0) execs,
(elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime,
(buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = nvl('&sql_id','d984a6ntjsq3u')
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3
/


__________________ PROCESS ______________________
set line 222
col machine for a10;
col P1TEXT for a10;
col P2TEXT for a10;
col EVENT for a20
select s.sid,s.serial#,s.inst_id,s.process,
s.machine,s.last_call_et,s.status,w.event,w.P1,w.P1TEXT,W.P2,w.P2TEXT 
from gv$session s, gv$session_wait w
where s.sid = w.sid and s.inst_id = w.inst_id
and s.process='3740';




SELECT a.inst_id,a.sid,a.SQL_ID,c.sql_text
FROM gv$session a, gv$sqlarea c
where c.address= a.sql_address
and c.hash_value = a.sql_hash_value
and username like 'STCC%'
--and sid=398;

SELECT a.inst_id,a.sid,a.SQL_ID,a.process, a.client_info ,c.sql_text
FROM gv$session a, gv$sqlarea c
where c.address= a.sql_address
and c.hash_value = a.sql_hash_value
and a.SQL_ID='7dwup5bn902rg';


SELECT a.sid,a.SQL_ID,c.sql_text
FROM v$session a, v$sqlarea c
where c.address= a.sql_address
and c.hash_value = a.sql_hash_value



## AWR ####
EXEC DBMS_WORKLOAD_REPOSITORY.create_snapshot;
!sleep 300
EXEC DBMS_WORKLOAD_REPOSITORY.create_snapshot;
spdba  
spdba @$ORACLE_HOME/rdbms/admin/awrrpt.sql
spdba @$ORACLE_HOME/rdbms/admin/awrrpti.sql
spdba @$ORACLE_HOME/rdbms/admin/awrddrpi.sql

select
      extract( day from snap_interval) *24*60+
      extract( hour from snap_interval) *60+
      extract( minute from snap_interval ) "Snapshot Interval",
      extract( day from retention) *24*60+
      extract( hour from retention) *60+
      extract( minute from retention ) "Retention Interval"
from dba_hist_wr_control;



exec dbms_workload_repository.modify_snapshot_settings (interval => 10);


PROCEDURE MODIFY_SNAPSHOT_SETTINGS
 Argument Name                  Type                    In/Out Default?
 ------------------------------ ----------------------- ------ --------
 RETENTION                      NUMBER                  IN     DEFAULT
 INTERVAL                       NUMBER                  IN     DEFAULT
 TOPNSQL                        VARCHAR2                IN
 DBID                           NUMBER                  IN     DEFAULT

exec dbms_workload_repository.modify_snapshot_settings (RETENTION=>600 ,interval => 10);

exec dbms_workload_repository.modify_snapshot_settings (interval => 30);
Automatic workload repository is a collection of persistent system performance statistics owned by SYS.
It resides in SYSAUX tablespace. By default snapshot are generated once every 60min and maintained for 7 days by default.

you can generate AWR reports by running SQL scripts:

1) The awrrpt.sql SQL script generates an HTML or text report that displays statistics for a range of snapshot Ids.
2) The awrrpti.sql SQL script generates an HTML or text report that displays statistics for a range of snapshot Ids on a specified database and instance.
3) The awrsqrpt.sql SQL script generates an HTML or text report that displays statistics of a particular SQL statement for a range of snapshot Ids. Run this report to inspect or debug the performance of a SQL statement.
4) The awrsqrpi.sql SQL script generates an HTML or text report that displays statistics of a particular SQL statement for a range of snapshot Ids on a specified SQL.
5) The awrddrpt.sql SQL script generates an HTML or text report that compares detailed performance attributes and configuration settings between two selected time periods.
6) The awrddrpi.sql SQL script generates an HTML or text report that compares detailed performance attributes and configuration settings between two selected time periods on a specific database and instance. 


@?/rdbms/admin/addmrpti.sql   x consigli su attivita' da effettuare per migliorare le performance del DB

@?/rdbms/admin/sqltrpt     x tuning sql

@?/rdbms/admin/ashrpt.sql

@?/rdbms/admin/awrddrpi.sql

5.3.4 Using Automatic Workload Repository Views

Typically, you would view the AWR data through Oracle Enterprise Manager or AWR reports. However, you can also view the statistics with the following views:

    V$ACTIVE_SESSION_HISTORY
    This view displays active database session activity, sampled once every second. See "Active Session History (ASH)".
    V$ metric views provide metric data to track the performance of the system
    The metric views are organized into various groups, such as event, event class, system, session, service, file, and tablespace metrics. These groups are identified in the V$METRICGROUP view.
    
    DBA_HIST views
    The DBA_HIST views contain historical data stored in the database. This group of views includes:
        DBA_HIST_ACTIVE_SESS_HISTORY displays the history of the contents of the in-memory active session history for recent system activity.
        DBA_HIST_BASELINE displays information about the baselines captured on the system
        DBA_HIST_DATABASE_INSTANCE displays information about the database environment
        DBA_HIST_SNAPSHOT displays information on snapshots in the system
        DBA_HIST_SQL_PLAN displays the SQL execution plans
        DBA_HIST_WR_CONTROL displays the settings for controlling AWR


select SNAP_ID,DBID,INSTANCE_NUMBER,to_char(BEGIN_INTERVAL_TIME,'DD-MM-YYYY HH24:MI'),to_char(END_INTERVAL_TIME,'DD-MM-YYYY HH24:MI') 
from DBA_HIST_SNAPSHOT
order by SNAP_ID desc;


select SNAP_ID,DBID,INSTANCE_NUMBER,to_char(BEGIN_INTERVAL_TIME,'DD-MM-YYYY HH24:MI'),to_char(END_INTERVAL_TIME,'DD-MM-YYYY HH24:MI') 
from DBA_HIST_SNAPSHOT
where to_char(BEGIN_INTERVAL_TIME,'DD-MM-YYYY HH24:MI') >= '02-01-2012 17:00' 
and   to_char(END_INTERVAL_TIME,'DD-MM-YYYY HH24:MI') <= '02-01-2012 19:00'
and INSTANCE_NUMBER in (4)
order by SNAP_ID;


SELECT
   output 
FROM   
   TABLE
   (dbms_workload_repository.awr_report_text
      (&DBID,&INSTANCE,&SNAP_START,&SNAP_STOP )
   );

set pagesize 2222

spool 3.log
SELECT
   output 
FROM   
   TABLE
   (dbms_workload_repository.awr_report_text
      (1209121739,2, 73576,73585 )
   );
   spool off




   
spool 2.html
SELECT
   output 
FROM   
   TABLE
   (dbms_workload_repository.awr_report_html
      (1642421591,2, 6194,6244 )
   );
   spool off









set line 120
 col COLUMN_NAME for a20
 set pagesize 3000
select INDEX_NAME,COLUMN_NAME,COLUMN_POSITION from dba_ind_columns 
where table_NAME='STCRMTB141P' and INDEX_OWNER='STCR_APPPRD' 
order by  INDEX_NAME,COLUMN_POSITION,COLUMN_NAME;


###### ______ ASM ____ Start 
c008++++++++++++
   PROBLEM : delete and create asm diskgroup , asm commandi 
++++++++++++
++++++++++++
   ACTION
++++++++++++

----- Presi da documentazione di installazione ORACLE -----
DATAINFRA                                 2 ORCL:ASMDISK_1_7               FG1
DATAINFRA                                 2 ORCL:ASMDISK_2_7               FG2

select name, header_status, path from v$asm_disk
where NAME like ';

_
++++++++++++
   NOTE
++++++++++++

_____________________ Redundancy ________________________

Mirroring Option 	Description
- 2-way mirroring Each extent has 1 mirrored copy.
- 3-way mirroring Each extent has 2 mirrored copies.
Unprotected ASM provides no mirroring. Used when mirroring is provided by the disk subsystem itself.




______________________ FAILGROUP ______________________
-  FAILGROUP   <======> CONTROLLER
-  viene creati al momento della creazione del diskgroup
- FAILGROUP è un subset di disks che sono associati in qualche maniera as esempuio per controller o per SAn


___________________ List of DiskGroup ______________________

	select name,state,TOTAL_MB,FREE_MB,USABLE_FILE_MB from v$ASM_DISKGROUP;
        /

set line 120        
	select name,state,(TOTAL_MB / 2),(FREE_MB / 2),(TOTAL_MB / 2)-(FREE_MB / 2) USED,USABLE_FILE_MB  
	from v$ASM_DISKGROUP;
        /
		NAME
		------------------------------
		ARCHROMO
		DATAINFRA
		DATAROMO


NAME                           STATE       (TOTAL_MB/2) (FREE_MB/2)       USED USABLE_FILE_MB
------------------------------ ----------- ------------ ----------- ---------- --------------
DG_A2PRD                       MOUNTED           577240      113885     463355          41730
DG_ALIMIPRD                    MOUNTED            72323       61887      10436          61887
DG_DWHMKPRD                    MOUNTED          2160260      356295    1803965         140269
DG_PUPRD                       MOUNTED           144310       92257      52053          92257
DG_RCGPRD                      MOUNTED           590137      101876     488261         101876
DG_RECOVERY                    MOUNTED          1488976      862560     626416         712515

_______________ STATS ASM ______________
set line 120
set pagesize 2222
col PATH for a30
select DG.NAME,DISk.PATH,READ_TIME,WRITE_TIME
from v$asm_diskgroup DG, v$asm_disk DISK
where DG.GROUP_NUMBER = DISK.GROUP_NUMBER
and DG.NAME in ('DG_EVA_STDWHCOLL','DG_EVA_ALIMICOL','DG_EVA_ALISPCOL');


READS 	            NUMBER 	Total number of I/O read requests for the disk
WRITES 	            NUMBER 	Total number of I/O write requests for the disk
READ_ERRS 	    NUMBER 	Total number of failed I/O read requests for the disk
WRITE_ERRS 	    NUMBER 	Total number of failed I/O write requests for the disk
READ_TIME 	    NUMBER 	Total I/O time (in hundredths of a second) for read requests for the disk if the TIMED_STATISTICS initialization parameter is set to true (0 if set to false)
WRITE_TIME 	     NUMBER 	Total I/O time (in hundredths of a second) for write requests for the disk if the TIMED_STATISTICS initialization parameter is set to true (0 if set to false)
BYTES_READ 	      NUMBER 	Total number of bytes read from the disk
BYTES_WRITTEN 	      NUMBER 	Total number of bytes written to the disk

 READ_TIME                                          NUMBER
 WRITE_TIME                                         NUMBER
 BYTES_READ                                         NUMBER
 BYTES_WRITTEN 


_________________ Association DiskGroup and ASm disk ___________________


       
			
			select d.name,g.name "DiskGroup",d.path,d.state
			from V$ASM_DISKGROUP G , v$asm_disk d  
			where d.GROUP_NUMBER = g.GROUP_NUMBER  
			and d.name like 'ASMDISK_BO_0B7B_140GB'
			order by g.group_number;  

	set line 222                                
	col DiskGroup for a20                       
	col DiskName for a30   
  col path for a30                   
 select g.name,d.name "DiskName",d.FAILGROUP,DISK_NUMBER,d.TOTAL_MB,d.FREE_MB,d.state,path
	from V$ASM_DISKGROUP G , v$asm_disk d                     
	where d.GROUP_NUMBER = g.GROUP_NUMBER 
	--and   g.name like '%DG%STDWH%%'
	and g.name like '%DG_A1PRD_STOR%'
	--and    d.path = '%4063%'  
	order by g.group_number,FAILGROUP;  
	                                
		set line 222                                
	col DiskGroup for a20                       
	col DiskName for a30   
  col path for a30     
	col path for a30                                          
	set line 222                                
	col DiskGroup for a20                       
	col DiskName for a50
	select d.name "DiskName",d.FAILGROUP,g.name "DiskGroup",d.TOTAL_MB,d.FREE_MB,d.TOTAL_MB-d.FREE_MB "Usage"
	from V$ASM_DISKGROUP G , v$asm_disk d                     
	where d.GROUP_NUMBER = g.GROUP_NUMBER                     
and   g.name like '%DG_EVA_STDWHCOLL%'                  
	order by g.group_number;    
	
	col path for a30                                          
	set line 222                                
	col DiskGroup for a20                       
	col DiskName for a50
	select d.name "DiskName",g.name "DiskGroup",d.TOTAL_MB,d.FREE_MB,d.TOTAL_MB-d.FREE_MB "Usage"
	from gV$ASM_DISKGROUP G , gv$asm_disk d                     
	where d.GROUP_NUMBER = g.GROUP_NUMBER                     
	--and   g.name like '%RECO%'
	--and    d.name = '%05E7%'               
	order by g.group_number;    
	
select * from v$asm_operation;




_________________ Contenuto su disco ASM ________________
COL full_alias_path for a120
set lines 132
set pages 1000



SELECT concat('+'||gname, sys_connect_by_path(aname, '/'))
full_alias_path
FROM
  (SELECT g.name gname, a.parent_index pindex, a.name aname,
    a.reference_index rindex FROM v$asm_alias a, v$asm_diskgroup g
      WHERE a.group_number = g.group_number)
        START WITH (mod(pindex, power(2, 24))) = 0
        CONNECT BY PRIOR rindex = pindex;
	
	
	
	
___________Per trovare dischi liberi da associare ad un nuovo DISKGROUP___________
	
	select path from v$asm_disk where path not in (
	select d.path
	from gV$ASM_DISKGROUP G , gv$asm_disk d
	where d.GROUP_NUMBER = g.GROUP_NUMBER);

	select path from v$asm_disk where path not in (
	select d.path
	from V$ASM_DISKGROUP G , v$asm_disk d
	where d.GROUP_NUMBER = g.GROUP_NUMBER);	
	
	
	    NAME           GROUP_NUMBER PATH                 FAILGROUP
	    -------------- ------------ -------------------- ------------------------------
	    ARCHROMO                  1 ORCL:ASMDISK_1_6     FG1
	    ARCHROMO                  1 ORCL:ASMDISK_2_6     FG2
	    DATAINFRA                 2 ORCL:ASMDISK_1_7     FG1
	    DATAINFRA                 2 ORCL:ASMDISK_2_7     FG2
	    DATAROMO                  3 ORCL:ASMDISK_1_5     FG1
	    DATAROMO                  3 ORCL:ASMDISK_1_1     FG1
	    DATAROMO                  3 ORCL:ASMDISK_2_2     FG2
	    DATAROMO                  3 ORCL:ASMDISK_2_3     FG2
	    DATAROMO                  3 ORCL:ASMDISK_2_4     FG2
	    DATAROMO                  3 ORCL:ASMDISK_2_5     FG2
	    DATAROMO                  3 ORCL:ASMDISK_1_2     FG1
	    DATAROMO                  3 ORCL:ASMDISK_1_4     FG1
	    DATAROMO                  3 ORCL:ASMDISK_1_3     FG1
	    DATAROMO                  3 ORCL:ASMDISK_2_1     FG2

____________________ DiskGroup Space Occupation _____________
	select group_number, name, total_mb, free_mb, state, type
	from v$asm_diskgroup;
	
  select group_number, name, total_mb/2, free_mb/2, state, type
	from v$asm_diskgroup;
	

_____________________ Free Asm Disk _________________________________
select GROUP_NUMBER,name, header_status, path from gv$asm_disk where  path like '%ORCL:ASMDISK_BO_4019_340GB%';
select GROUP_NUMBER,name, header_status, path from v$asm_disk where HEADER_STATUS not like 'MEMBER';
MOUNT_STATUS
select GROUP_NUMBER,name from v$asm_diskgroup;

AME                           HEADER_STATU PATH
------------------------------ ------------ 
                               FOREIGN      /dev/raw/raw3      <--- 
                               FOREIGN      /dev/raw/raw4      <--- Internal SCSI disks
                               FOREIGN      /dev/raw/raw5      <--- 
                               FORMER       ORCL:ASMDISK_2_7   <--- 
                               FORMER       ORCL:ASMDISK_1_7   <--- dropped disk
ASMDISK_1_1                    MEMBER       ORCL:ASMDISK_1_1   <--- 
ASMDISK_1_2                    MEMBER       ORCL:ASMDISK_1_2   <--- 
ASMDISK_1_3                    MEMBER       ORCL:ASMDISK_1_3   <--- 
ASMDISK_1_4                    MEMBER       ORCL:ASMDISK_1_4   <--- Member of diskgroup
ASMDISK_1_5                    MEMBER       ORCL:ASMDISK_1_5   <--- 
ASMDISK_1_6                    MEMBER       ORCL:ASMDISK_1_6   <--- 
ASMDISK_2_1                    MEMBER       ORCL:ASMDISK_2_1   <--- 
ASMDISK_2_2                    MEMBER       ORCL:ASMDISK_2_2   <--- 
ASMDISK_2_3                    MEMBER       ORCL:ASMDISK_2_3   <--- 
ASMDISK_2_4                    MEMBER       ORCL:ASMDISK_2_4   <--- 
ASMDISK_2_5                    MEMBER       ORCL:ASMDISK_2_5   <--- 
ASMDISK_2_6                    MEMBER       ORCL:ASMDISK_2_6   <--- 


alter diskgroup DG_DOFSVL add  disk 'ORCL:ASMDISK_1_3' 


ALTER DISKGROUP DB_FTIMICOL REBALANCE POWER 8 ;
alter system set asm_power_limit=10 scope=memory;
select * from v$asm_operation;


_______________ Aggiungi disco in campus ______________

alter diskgroup DG_STDWHCOLL add failgroup fg2 disk 'ORCL:ASMDISK_BO_00D8_80GB'
failgroup fg1 disk 'ORCL:ASMDISK_SC_00E0_80GB';
ALTER DISKGROUP DG_STDWHCOLL REBALANCE POWER 8 ;



ALTER DISKGROUP ALL MOUNT;


____ linee Guida ABBA_____


 DROP/ADD disk (current mode)
   -------------------
   ALTER DISKGROUP xxxx DROP DISK disk1;
   ALTER DISKGROUP xxxx DROP DISK disk2;
   ALTER DISKGROUP xxxx DROP DISK disk3;
   
   <- ARB0 ORA-1031 
   <- problems observed
   <- over stressing 
   
   DROP/ADD disk (new)
   ---------
   to be tested in TEST ENV before apply

ASMDISK_BO_0457_140GB_R1       DG_ANPRD                 143996      42677 NORMAL   FG1
ASMDISK_BO_021E_70GB           DG_ANPRD                  71994      20250 NORMAL   FG1
ASMDISK_BO_0923_140GB          DG_ANPRD                 143996      40802 NORMAL   FG1
ASMDISK_SC_002A_140GB          DG_ANPRD                 143996      41106 NORMAL   FG2
ASMDISK_SC_01A5_70GB           DG_ANPRD                  71994      20596 NORMAL   FG2
ASMDISK_SC_0A0D_140GB_R2       DG_ANPRD                 143996      42031 NORMAL   FG2

   
   opz1)
   ALTER DISKGROUP xxxx DROP DISK disk1,disk2,disk3 REBALANCE POWER 0 WAIT;
    ALTER DISKGROUP xxxxxx REBALANCE POWER 4 WAIT;
      ALTER DISKGROUP DG_STDWHPRD ADD  FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_0125_70GB','ORCL:ASMDISK_BO_06D2_144GB'
       FAILGROUP FG2 DISK 'ORCL:ASMDISK_SC_0337_70GB','ORCL:ASMDISK_SC_0008_144GB'
      REBALANCE POWER 0 WAIT;
      
       ALTER DISKGROUP DG_STDWHPRD ADD 
       FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_0301_143GB'
       FAILGROUP FG2 DISK 'ORCL:ASMDISK_SC_00FD_143GB'
      REBALANCE POWER 0 WAIT;
   (check DGs,Disk from all ASM instances)
   ALTER DISKGROUP DG_STDWHPRD REBALANCE POWER 4 WAIT;
   (command freezes until complete.. wait)

_______________ my ste ___________
 ALTER DISKGROUP DG_ROPRD ADD  FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_066e_140GB'
       FAILGROUP FG2 DISK 'ORCL:ASMDISK_SC_0569_140GB'
      REBALANCE POWER 0 WAIT;
       ALTER DISKGROUP DG_ROPRD REBALANCE POWER 4 WAIT;


ORCL:ASMDISK_BO_021E_70GB
ORCL:ASMDISK_SC_01A5_70GB

ALTER DISKGROUP DG_ANPRD 
      ADD  FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_0496_140GB'
       FAILGROUP FG2 DISK 'ORCL:ASMDISK_SC_0049_140GB'
      ;
      
      ORCL:ASMDISK_BO_0496_140GB
      ORCL:ASMDISK_SC_0049_140GB

   ALTER DISKGROUP DG_ANPRD DROP 
   DISK ORCL:ASMDISK_BO_0496_140GB,ASMDISK_SC_0049_140GB_R1 
   REBALANCE POWER 4 ;
    
    ALTER DISKGROUP DG_A1COL REBALANCE POWER 4 ;
      ALTER DISKGROUP DG_STDWHCOL 
      ADD  FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_0632_140GB'
       FAILGROUP FG2 DISK 'ORCL:ASMDISK_SC_0581_140GB'
      REBALANCE POWER 0 WAIT;
  
   ALTER DISKGROUP DG_STDWHCOL REBALANCE POWER 4 WAIT;
  
ALTER DISKGROUP DG_ANPRD REBALANCE POWER 4 ;

   opz2)
   ALTER DISKGROUP xxxx DROP DISK disk1,disk2,disk3 REBALANCE POWER 4 WAIT;
   
   
ORCL:ASMDISK_BO_0900_140GB
ORCL:ASMDISK_SC_09B6_140GB
create DISKGROUP DG_MOVE ADD  FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_0900_140GB'
 FAILGROUP FG2 DISK '

CREATE DISKGROUP DG_MOVE NORMAL REDUNDANCY 
FAILGROUP FG2 DISK 'ORCL:ASMDISK_SC_09B6_140GB'
FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_0900_140GB';


CREATE DISKGROUP DG_MOVE NORMAL REDUNDANCY 
FAILGROUP FG2 DISK 'ORCL:ASMDISK_SC_09B6_140GB'
FAILGROUP FG1 DISK 'ORCL:ASMDISK_BO_0900_140GB';




##### ______ ASM _____ End




________________ RDBMS _____ Start
_____________ TABLESPACE USAGE ALLOCATED FREE __________

SELECT a.tablespace_name,  sum(TRunc((a.bytes)/1000000000)) allocated_GB, 
 sum(trunc(b.free_bytes/1000000000)) free_GB,
 sum(TRunc((a.bytes)/1000000000)) - sum(trunc(b.free_bytes/1000000000)) DIFF_GB
 FROM dba_data_files a, 
 (SELECT file_id, SUM(bytes) free_bytes
 FROM dba_free_space b GROUP BY file_id) b
 WHERE a.file_id=b.file_id
 group by a.tablespace_name
 ORDER BY a.tablespace_name;
 
 
 SELECT a.tablespace_name,  sum(TRunc((a.bytes)/1000000)) allocated_MB, 
 sum(trunc(b.free_bytes/1000000)) free_MB,
 sum(TRunc((a.bytes)/1000000)) - sum(trunc(b.free_bytes/1000000)) DIFF_MB
 FROM dba_data_files a, 
 (SELECT file_id, SUM(bytes) free_bytes
 FROM dba_free_space b GROUP BY file_id) b
 WHERE a.file_id=b.file_id
 and a.tablespace_name like 'STCR%'
 group by a.tablespace_name
 ORDER BY a.tablespace_name;
 
 
 The beauty of the time model is that it gives a high-level overview and hierarchy of where time is being spent. For instance, DB Time is the total amount of elapsed time that was spent performing user-level calls. DB Time is then made up of additional timings such as DB CPU, connection management call elapsed time, sequence load elapsed time, etc. – providing a nice look deep into where 
 
  select stat_name, trunc(value/1000000,2) seconds from v$sys_time_model order by 2 desc;



From the results of this query it is easy to see the top consumers of time. When using the time model to tune a database, it is best to look at DB time first to get some indication of the load on the databases. The time accumulated for DB time is considered the workload of the database as it represents the total time for database calls, an aggregation of all CPU and wait times for all sessions and excluding idle wait events. Since DB time is the aggregation of all CPU and wait times, working or not working, and is for all sessions, this value can be greater than real time (wall clock time) or any amount of CPU time actually available in the system. Assume you have 1 CPU and 1,000 users where only 500 users are able to work at any one time. This leaves the 500 users in a wait for some resource (CPU, I/O, latch, etc.) but just so long as those idle 500 users are waiting on a non-idle wait event, their wait times will be added to DB time. 



SELECT LPAD(' ', 2*level-1)||stat_name stat_name, 
       trunc(value/1000000,2) seconds 
  FROM (
select 0 id, 9 pid, null stat_name, null value from dual union
select decode(stat_name,'DB time',10) id ,
       decode(stat_name,'DB time',0) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'DB time' union
select decode(stat_name,'DB CPU',20) id ,
       decode(stat_name,'DB CPU',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'DB CPU' union
select decode(stat_name,'connection management call elapsed time',21) id ,
       decode(stat_name,'connection management call elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'connection management call elapsed time' union
select decode(stat_name,'sequence load elapsed time',22) id ,
       decode(stat_name,'sequence load elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'sequence load elapsed time' union
select decode(stat_name,'sql execute elapsed time',23) id ,
       decode(stat_name,'sql execute elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'sql execute elapsed time' union
select decode(stat_name,'parse time elapsed',24) id ,
       decode(stat_name,'parse time elapsed',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'parse time elapsed' union
select decode(stat_name,'hard parse elapsed time',30) id ,
       decode(stat_name,'hard parse elapsed time',24) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'hard parse elapsed time' union
select decode(stat_name,'hard parse (sharing criteria) elapsed time',40) id ,
       decode(stat_name,'hard parse (sharing criteria) elapsed time',30) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'hard parse (sharing criteria) elapsed time' union
select decode(stat_name,'hard parse (bind mismatch) elapsed time',50) id ,
       decode(stat_name,'hard parse (bind mismatch) elapsed time',40) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'hard parse (bind mismatch) elapsed time' union
select decode(stat_name,'failed parse elapsed time',31) id ,
       decode(stat_name,'failed parse elapsed time',24) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'failed parse elapsed time' union
select decode(stat_name,'failed parse (out of shared memory) elapsed time',41) id ,
       decode(stat_name,'failed parse (out of shared memory) elapsed time',31) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'failed parse (out of shared memory) elapsed time' union
select decode(stat_name,'PL/SQL execution elapsed time',25) id ,
       decode(stat_name,'PL/SQL execution elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'PL/SQL execution elapsed time' union
select decode(stat_name,'inbound PL/SQL rpc elapsed time',26) id ,
       decode(stat_name,'inbound PL/SQL rpc elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'inbound PL/SQL rpc elapsed time' union
select decode(stat_name,'PL/SQL compilation elapsed time',27) id ,
       decode(stat_name,'PL/SQL compilation elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'PL/SQL compilation elapsed time' union
select decode(stat_name,'Java execution elapsed time',28) id ,
       decode(stat_name,'Java execution elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'Java execution elapsed time' union
select decode(stat_name,'repeated bind elapsed time',29) id ,
       decode(stat_name,'repeated bind elapsed time',10) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'repeated bind elapsed time' union
select decode(stat_name,'background elapsed time',1) id ,
       decode(stat_name,'background elapsed time',0) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'background elapsed time' union
select decode(stat_name,'background cpu time',2) id ,
       decode(stat_name,'background cpu time',1) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'background cpu time' union
select decode(stat_name,'RMAN cpu time (backup/restore)',3) id ,
       decode(stat_name,'RMAN cpu time (backup/restore)',2) pid , stat_name, value
  from v$sys_time_model
 where stat_name = 'RMAN cpu time (backup/restore)')
CONNECT BY PRIOR id = pid START WITH id = 0;



------------- Monitor datapump ---------------

select sid, serial#, sofar, totalwork,
dp.owner_name, dp.state, dp.job_mode,
sl.ELAPSED_SECONDS,sl.TIME_REMAINING,sl.UNITS
from gv$session_longops sl, gv$datapump_job dp
where sl.opname = dp.job_name and sofar != totalwork;


___ 	Monthly Cumulative Tablespace Allocated Space Usage ____


SELECT decode(metric_column, 'spaceAllocated', 'spaceAllocated_GB','spaceUsed', 'spaceUsed_GB'),
month_timestamp, avg(value)
FROM (SELECT m.metric_column AS metric_column, TO_DATE(TO_CHAR(m.rollup_timestamp,'YYYY-MM'), 'YYYY-MM') AS month_timestamp,sum(m.average/1024) AS value
				FROM  mgmt$metric_daily m,mgmt$target_type t
				WHERE
				t.TARGET_NAME like 'GOLD0ONP' AND
				(t.target_type='rac_database' OR
				(t.target_type='oracle_database' AND t.TYPE_QUALIFIER3 != 'RACINST')) AND
				m.target_guid=t.target_guid AND
				m.metric_guid=t.metric_guid AND
				t.metric_name='tbspAllocation' AND
				(t.metric_column='spaceAllocated' OR t.metric_column='spaceUsed') AND
				m.rollup_timestamp >= SYSDATE-30 AND
				m.rollup_timestamp <= SYSDATE
				and m.metric_column = 'spaceUsed'
				GROUP BY m.metric_column, m.rollup_timestamp
				)
GROUP BY metric_column, month_timestamp
ORDER BY month_timestamp ASC, metric_column DESC  ;            


select ROLLUP_TIMESTAMP,key_value,trunc(AVERAGE) 
FROM  mgmt$metric_hourly m,mgmt$target_type t
                                               WHERE
                                              t.TARGET_NAME like 'STDWHPRD' AND
                                               (t.target_type='rac_database' OR
                                               (t.target_type='oracle_database' AND t.TYPE_QUALIFIER3 != 'RACINST')) AND
                                               m.target_guid=t.target_guid AND
                                               m.metric_guid=t.metric_guid AND
                                               m.rollup_timestamp >= SYSDATE-15 AND
                                               m.rollup_timestamp <= SYSDATE
                                               and m.metric_column = 'spaceUsed'
and key_value in ('STCRTSBL0001D','STCRTSBL0001DX_LR','STCRTSBL0001X','STCRTSBL0002D','STCRTSBL0002X',
'STEXTSBL0001D','STEXTSBL0001X','STEXTSBL0002D','STEXTSBL0002X');


SELECT decode(metric_column, 'spaceAllocated', 'spaceAllocated_GB','spaceUsed', 'spaceUsed_GB'),
month_timestamp, avg(value)
FROM (SELECT m.metric_column AS metric_column, TO_DATE(TO_CHAR(m.rollup_timestamp,'YYYY-MM'), 'YYYY-MM') AS month_timestamp,sum(m.average/1024) AS value
				FROM  mgmt$metric_hourly m,mgmt$target_type t
				WHERE
				t.TARGET_NAME like 'STDWHPRD' AND
				(t.target_type='rac_database' OR
				(t.target_type='oracle_database' AND t.TYPE_QUALIFIER3 != 'RACINST')) AND
				m.target_guid=t.target_guid AND
				m.metric_guid=t.metric_guid AND
				t.metric_name='tbspAllocation' AND
				(t.metric_column='spaceAllocated' OR t.metric_column='spaceUsed') AND
				m.rollup_timestamp >= SYSDATE-30 AND
				m.rollup_timestamp <= SYSDATE
				and m.metric_column = 'spaceUsed'
				GROUP BY m.metric_column, m.rollup_timestamp
				)
GROUP BY metric_column, month_timestamp
ORDER BY month_timestamp ASC, metric_column DESC  ;   


sqlplus system/oracle@emrep da rrcobo01vp
SELECT TARGET_NAME,decode(metric_column, 'spaceAllocated', 'spaceAllocated_GB','spaceUsed', 'spaceUsed_GB') AS TYPE,
month_timestamp, trunc(avg(value)) as SPACE_GB
FROM (SELECT 			t.TARGET_NAME,
									m.metric_column AS metric_column, 
									TO_DATE(TO_CHAR(m.rollup_timestamp,'YYYY-MM'), 'YYYY-MM') AS month_timestamp,
									sum(m.average/1024) AS value
				FROM  mgmt$metric_daily m,mgmt$target_type t
				WHERE
				t.TARGET_NAME like '%PRD%' AND
				(t.target_type='rac_database' OR
				(t.target_type='oracle_database' AND t.TYPE_QUALIFIER3 != 'RACINST')) AND
				m.target_guid=t.target_guid AND
				m.metric_guid=t.metric_guid AND
				t.metric_name='tbspAllocation' AND
				(t.metric_column='spaceAllocated' OR t.metric_column='spaceUsed') AND
				m.rollup_timestamp >= '01-JAN-10' AND
				m.rollup_timestamp <= SYSDATE
				and m.metric_column = 'spaceAllocated'
				GROUP BY t.TARGET_NAME,m.metric_column, m.rollup_timestamp
				)
GROUP BY TARGET_NAME,metric_column, month_timestamp
ORDER BY month_timestamp ASC, metric_column DESC  ;            

____ Interconnect Latency ______        
select round((sum(v1.value)/sum(v2.value))*10,1) latency_ms, to_char(s.END_INTERVAL_TIME,'DD-MON-YYYY HH24:MI') snap_time
from DBA_HIST_SYSSTAT v1, DBA_HIST_SYSSTAT v2, dba_hist_snapshot s
where s.END_INTERVAL_TIME > sysdate - 7
and v1.SNAP_ID=v2.SNAP_ID
and v1.SNAP_ID=s.SNAP_ID
and s.INSTANCE_NUMBER=1
and ((v1.stat_name='gc cr block receive time' and v2.stat_name='gc cr blocks received')
or (v1.stat_name='global cache cr block receive time' and v2.stat_name='global cache cr blocks received'))
group by s.SNAP_ID, to_char(s.END_INTERVAL_TIME,'DD-MON-YYYY HH24:MI')
order by s.SNAP_ID
/

---- toglie rumore di fondo altre instanze
set numwidth 20
column "AVG CR BLOCK RECEIVE TIME (ms)" format 9999999.9
select
b1.inst_id,
b2.value "GCS CR BLOCKS RECEIVED",
b1.value "GCS CR BLOCK RECEIVE TIME",
((b1.value / b2.value) * 10) "AVG CR BLOCK RECEIVE TIME (ms)"
from gv$sysstat b1,
gv$sysstat b2
where b1.name = 'gc cr block receive time'
and b2.name = 'gc cr blocks received'
and b1.inst_id = b2.inst_id ;


______ INDEX UNUSABLE ___
select owner,index_name from dba_indexes where status like 'INVALID' OR STATUS LIKE 'UNUSABLE';

select index_owner,index_name,partition_name from dba_ind_partitions where status like 'INVALID' OR STATUS LIKE 'UNUSABLE';

select index_owner,index_name,partition_name,subpartition_name,status 
from dba_ind_subpartitions 
where status like 'UN%';

select 'alter index '||owner||'.'||index_name||' rebuild ;' from dba_indexes where status like 'UNUSABLE';



++++++++++++++++++++++++++++++++++++++
how-find-default-tablespace-partitioned-tables.html
++++++++++++++++++++++++++++++++++++++

SELECT def_tablespace_name FROM dba(all,user)_part_tables;

SELECT owner,table_name,def_tablespace_name,count(*) FROM dba_part_tables where owner='STCR_APPPRD'
group by owner,table_name,def_tablespace_name;


SELECT owner,index_name,def_tablespace_name,count(*) FROM dba_part_indexes where owner='STCR_APPPRD'
group by owner,index_name,def_tablespace_name;



______ INDEX REBUILD ___

creare sql dinamico:

select 'alter index ' || index_owner ||'.'|| index_name || ' REBUILD PARTITION ' || partition_name || ';' from dba_ind_partitions 
where STATUS like 'INVALID' or STATUS like 'UNUSABLE'; 


select 'alter index '||OWNER||'.'||INDEX_NAME||' rebuild storage (initial 0) ;' 
from dba_indexes 
where STATUS like 'INVALID' or STATUS like 'UNUSABLE'; 


select 'alter index ' || index_owner ||'.' || index_name || ' REBUILD SUBPARTITION ' || subpartition_name || ';' from dba_ind_subpartitions 
where STATUS like 'INVALID' or STATUS like 'UNUSABLE'; 



____ PURGE ____
select 'purge '||segment_type||' '||owner||'."'|| segment_name||'";'
 from dba_segments 
 where tablespace_name like 'MXTSBL0001D'
and segment_name like 'BIN%'
and segment_type = 'TABLE';


select 'purge '||segment_type||' '||owner||'."'|| segment_name||'";'
 from dba_segments 
 where tablespace_name like 'STCRTSBL0003D'
and segment_name like 'BIN%'
;


select 'purge  table '||owner||'."'|| segment_name||'";'
 from dba_segments 
 where segment_name like 'BIN%'
;


select 'purge '||segment_type||' '||owner||'."'|| segment_name||'";'
 from dba_segments 
 where segment_name like 'BIN%'
 ;

select 'purge '||segment_type||' '||owner||'."'|| segment_name||'";'
 from dba_segments 
 where segment_name like 'BIN%'
 and segment_type = 'INDEX';
;

++++++++++++++++++++++++++++++++++++++
em grid disk asm
++++++++++++++++++++++++++++++++++++++

 desc MGMT$METRIC_HOURLY
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 TARGET_NAME                                        VARCHAR2(256)
 TARGET_TYPE                                        VARCHAR2(64)
 TARGET_GUID                                        RAW(16)
 METRIC_NAME                                        VARCHAR2(64)
 METRIC_COLUMN                                      VARCHAR2(64)
 METRIC_GUID                                        RAW(16)
 METRIC_LABEL                                       VARCHAR2(64)
 COLUMN_LABEL                                       VARCHAR2(256)
 KEY_VALUE                                          VARCHAR2(256)
 KEY_VALUE2                                         VARCHAR2(256)
 KEY_VALUE3                                         VARCHAR2(256)
 KEY_VALUE4                                         VARCHAR2(256)
 KEY_VALUE5                                         VARCHAR2(256)
 ROLLUP_TIMESTAMP                                   DATE
 SAMPLE_COUNT                                       NUMBER
 AVERAGE                                            NUMBER
 MINIMUM                                            NUMBER
 MAXIMUM                                            NUMBER
 STANDARD_DEVIATION                                 NUMBER



select distinct(target_name) from MGMT$METRIC_HOURLY;
 select distinct(metric_name)  FROM  MGMT$METRIC_HOURLY where metric_name like '%storage%';
  
  
 select metric_name,metric_column
  FROM  MGMT$METRIC_HOURLY
  WHERE target_name in( 'rrdbbo10fp')
  AND rollup_timestamp >= sysdate-1
  AND metric_name = 'host_storage_history'
  group by metric_name,metric_column
  order by 1;
  
METRIC_NAME                                                      METRIC_COLUMN
---------------------------------------------------------------- ----------------------------------------------------------------
host_storage_history                                             total_allocated
host_storage_history                                             local_fs_used
host_storage_history                                             total_free
host_storage_history                                             asm_overhead
host_storage_history                                             summarized_dbs
host_storage_history                                             total_overhead
host_storage_history                                             total_used
host_storage_history                                             summarized_hosts
host_storage_history                                             total_dbs
host_storage_history                                             unmonitored_nfs
host_storage_history                                             asm_unallocated
host_storage_history                                             total_asm
host_storage_history                                             disks_unallocated
host_storage_history                                             asm_allocated
host_storage_history                                             local_fs_free
host_storage_history                                             total_unallocated
host_storage_history                                             other_map_err
host_storage_history                                             summarized_asm
 
 
 select to_date(rollup_timestamp, 'DD-MM-YYYY HH24:MI'),AVERAGE
  FROM  MGMT$METRIC_HOURLY
  WHERE target_name in( 'rrdbbo10fp')
  AND rollup_timestamp >= sysdate-2
  AND metric_name = 'host_storage_history';
 
---asm   
 select * 
  FROM  MGMT$METRIC_HOURLY
  WHERE target_name in( 'rrdbbo01fp')
  AND rollup_timestamp >= sysdate-10
  AND metric_name = 'host_storage_history'
  AND METRIC_COLUMN like 'asm%'
  order by 1;
  


  
++++++++++++++++++++++++++++++++++++++
em matric
++++++++++++++++++++++++++++++++++++++


METRIC_NAME                                                      METRIC_COLUMN                                                      COUNT(*)
---------------------------------------------------------------- ---------------------------------------------------------------- ----------
CRSStatus                                                        CRS_status                                                              132
DiskActivity                                                     DiskActivityavserv                                                     2112
DiskActivity                                                     DiskActivitybusy                                                       2112
DiskActivity                                                     DiskBlkioTicks                                                         2112
DiskActivity                                                     diskActivNReadsDiff                                                    2112
DiskActivity                                                     diskActivNWritesDiff                                                   2112
DiskActivity                                                     diskActivReadsBlks                                                     2112
DiskActivity                                                     diskActivReadsPerSec                                                   2112
DiskActivity                                                     diskActivWritesBlks                                                    2112
DiskActivity                                                     diskActivWritesPerSec                                                  2112
FileMonitoring                                                   file_size                                                               132
FileMonitoring                                                   file_sizechangerate                                                     132
Filesystems                                                      pctAvailable                                                           1290
Filesystems                                                      size                                                                   1290
Load                                                             activeMem                                                               132
Load                                                             cpuIOWait                                                               132
Load                                                             cpuKernel                                                               132
Load                                                             cpuLoad                                                                 132
Load                                                             cpuLoad_15min                                                           132
Load                                                             cpuLoad_1min                                                            132
Load                                                             cpuUser                                                                 132
Load                                                             cpuUtil                                                                 132
Load                                                             logicMemfreePct                                                         132
Load                                                             longestServ                                                             132
Load                                                             memUsedPct                                                              132
Load                                                             memfreePct                                                              132
Load                                                             noOfProcs                                                               132
Load                                                             noOfUsers                                                               132
Load                                                             pgScanRate                                                              132
Load                                                             swapUtil                                                                132
Load                                                             totIO                                                                   132
Network                                                          collisions                                                              660
Network                                                          inpErrors                                                               924
Network                                                          outErrors                                                               660
Network                                                          readRate                                                               1452
Network                                                          readThroughput                                                          242
Network                                                          totalErrorRate                                                          924
Network                                                          totalRate                                                              1452
Network                                                          totalThroughput                                                         242
Network                                                          writeRate                                                              1452
Network                                                          writeThroughput                                                         242
PagingActivity                                                   PagingActivitypgscan                                                    132
PagingActivity                                                   PagingActivityppgin                                                     132
PagingActivity                                                   PagingActivityppgout                                                    132
PagingActivity                                                   Pgactive                                                                132
ProgramResourceUtilization                                       prog_max_cpu_time                                                       132
ProgramResourceUtilization                                       prog_max_cpu_util                                                       132
ProgramResourceUtilization                                       prog_max_process_count                                                  132
ProgramResourceUtilization                                       prog_max_rss                                                            132
ProgramResourceUtilization                                       prog_min_process_count                                                  132
ProgramResourceUtilization                                       prog_total_cpu_time                                                     132
ProgramResourceUtilization                                       prog_total_cpu_util                                                     132
Swap_Area_Status                                                 swapfreesize                                                             10
UDM                                                              NumValue                                                                132
host_storage_history                                             asm_allocated                                                             5
host_storage_history                                             asm_overhead                                                              5
host_storage_history                                             asm_unallocated                                                           5
host_storage_history                                             db_free                                                                   4
host_storage_history                                             db_used                                                                   4
host_storage_history                                             disks_unallocated                                                         5
host_storage_history                                             local_fs_free                                                             5
host_storage_history                                             local_fs_used                                                             5
host_storage_history                                             other_map_err                                                             5
host_storage_history                                             summarized_asm                                                            5
host_storage_history                                             summarized_dbs                                                            5
host_storage_history                                             summarized_hosts                                                          5
host_storage_history                                             total_allocated                                                           5
host_storage_history                                             total_asm                                                                 5
host_storage_history                                             total_dbs                                                                 5
host_storage_history                                             total_free                                                                5
host_storage_history                                             total_overhead                                                            5
host_storage_history                                             total_unallocated                                                         5
host_storage_history                                             total_used                                                                5
host_storage_history                                             unmonitored_nfs                                                           5
proc_zombie                                                      host_proc_zombie_percnt                                                   7





++++++++++++++++++++++++++++++++++++++
diskactivity
++++++++++++++++++++++++++++++++++++++


set line 3333
set pagesize 3333
col TARGET_NAME for a16
set feed off
SELECT target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI'), trunc(average), trunc(MINIMUM),trunc(MAXIMUM),trunc(STANDARD_DEVIATION)
FROM MGMT$METRIC_HOURLY
WHERE target_name in( 'rrdbbo01fp','rrdbbo02fp','rrdbbo03fp','rrdbsc01fp','rrdbsc02fp','rrdbsc03fp')
AND metric_name = 'Load'
AND metric_column = 'totIO'
AND rollup_timestamp >= sysdate-30
order by target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI') ;



_____ CPU ____
SELECT rollup_timestamp "Date", average "CPU Usage %"
FROM MGMT$METRIC_DAILY
WHERE target_name like '%rrdbbo01fp%'
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp <= sysdate-2;


SELECT target_name,rollup_timestamp "Date", average, MINIMUM,MAXIMUM,STANDARD_DEVIATION
FROM MGMT$METRIC_DAILY
WHERE target_name in( 'rrdbbo01fp','rrdbbo02fp','rrdbbo03fp','rrdbsc01fp','rrdbsc02fp','rrdbsc03p')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate-1
order by target_name ;

--- cpu util hourly
SELECT target_name,trunc(rollup_timestamp), trunc(average), trunc(MINIMUM),trunc(MAXIMUM),trunc(STANDARD_DEVIATION)
FROM MGMT$METRIC_DAILY
WHERE target_name in( 'rrdbbo01fp','rrdbbo02fp','rrdbbo03fp','rrdbsc01fp','rrdbsc02fp','rrdbsc03fp')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate-60
order by target_name,trunc(rollup_timestamp) ;

SELECT target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI'), trunc(average), trunc(MINIMUM),trunc(MAXIMUM),trunc(STANDARD_DEVIATION)
FROM MGMT$METRIC_HOURLY
WHERE target_name in( 'rrdbbo01fp','rrdbbo02fp','rrdbbo03fp','rrdbsc01fp','rrdbsc02fp','rrdbsc03fp')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate-7
order by target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI') ;

set line 3333
set pagesize 3333
col TARGET_NAME for a16
set feed off
SELECT target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI'), trunc(average), trunc(MINIMUM),trunc(MAXIMUM),trunc(STANDARD_DEVIATION)
FROM MGMT$METRIC_HOURLY
WHERE target_name in( 'rrdbbo01fp','rrdbbo02fp','rrdbbo03fp','rrdbsc01fp','rrdbsc02fp','rrdbsc03fp')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate-30
order by target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI') ;



set line 3333
set pagesize 3333
col TARGET_NAME for a16
set feed off
SELECT target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI'), trunc(average), trunc(MINIMUM),trunc(MAXIMUM),trunc(STANDARD_DEVIATION)
FROM MGMT$METRIC
WHERE target_name in( 'rrdbbo01fp','rrdbbo02fp','rrdbbo03fp','rrdbsc01fp','rrdbsc02fp','rrdbsc03fp')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate
order by target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI') ;

____ CLU ROMO
set line 3333
set pagesize 3333
col TARGET_NAME for a16
set feed off
set head off
set echo off
spool ste.txt
SELECT target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI'), trunc(average),trunc(MAXIMUM)
FROM MGMT$METRIC_HOURLY
WHERE target_name in( 'rrdbbo01fp','rrdbbo02fp','rrdbbo03fp','rrdbsc01fp','rrdbsc02fp','rrdbsc03fp')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate-26
--and to_number(to_char(rollup_timestamp,'HH24')) between  7 and 19 
order by target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI') ;
spool off;

!grep -i rrdbbo01fp ste.txt > rrdbbo01fp.txt
!grep -i rrdbbo02fp ste.txt > rrdbbo02fp.txt
!grep -i rrdbbo03fp ste.txt > rrdbbo03fp.txt
!grep -i rrdbsc01fp ste.txt > rrdbsc01fp.txt
!grep -i rrdbsc02fp ste.txt > rrdbsc02fp.txt
!grep -i rrdbsc03fp ste.txt > rrdbsc03fp.txt


!steftp rrdbbo01fp.txt  
!steftp rrdbbo02fp.txt  
!steftp rrdbbo03fp.txt  
!steftp rrdbsc01fp.txt  
!steftp rrdbsc02fp.txt  
!steftp rrdbsc03fp.txt  

exit;

____ CLU ANAGE
set line 3333
set pagesize 3333
col TARGET_NAME for a16
set feed off
set head off
set echo off
spool ste.txt
SELECT target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI'), trunc(average),trunc(MAXIMUM)
FROM MGMT$METRIC_HOURLY
WHERE target_name in( 'rrdbbo05fp','rrdbbo06fp','rrdbsc05fp','rrdbsc06fp')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate-19
and to_number(to_char(rollup_timestamp,'HH24')) between  7 and 19 
order by target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI') ;
spool off;

!grep -i rrdbbo05fp ste.txt > rrdbbo05fp.txt
!grep -i rrdbbo06fp ste.txt > rrdbbo06fp.txt
!grep -i rrdbsc05fp ste.txt > rrdbsc05fp.txt
!grep -i rrdbsc06fp ste.txt > rrdbsc06fp.txt


!steftp rrdbbo05fp.txt  
!steftp rrdbbo06fp.txt  
!steftp rrdbsc05fp.txt  
!steftp rrdbsc06fp.txt  

exit;


____ CLU DWH
set line 3333
set pagesize 3333
col TARGET_NAME for a16
set feed off
set head off
set echo off
spool ste.txt
SELECT target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI'), trunc(average),trunc(MAXIMUM)
FROM MGMT$METRIC_HOURLY
WHERE target_name in( 'rrdbbo04fp','rrdbsc04fp')
AND metric_name = 'Load'
AND metric_column = 'cpuUtil'
AND rollup_timestamp >= sysdate-19
and to_number(to_char(rollup_timestamp,'HH24')) between  0 and 23 
order by target_name,to_char(rollup_timestamp,'DD-MM-YYYY:HH24:MI') ;
spool off;

!grep -i rrdbbo04fp ste.txt > rrdbbo04fp.txt
!grep -i rrdbsc04fp ste.txt > rrdbsc04fp.txt



!steftp rrdbbo04fp.txt  
!steftp rrdbsc04fp.txt  

exit;






________________ RDBMS ______ End

___________ STATS _____ Start





Ottimizzatore best practics


http://www.dba-oracle.com/oracle_tips_optimizer_cost_model.htm

Oracle RDBMS System Statistics
Oracle has introduced workload statistics in Oracle 9i to gather important information about system such as single andmultiple block read time, CPU speed, and various system throughputs. Optimizer takes system statistics into account,when it computes the cost of query execution plans. Failure to gather workload statistics may result in sub-optimalexecution plans for queries, excessive temporary space consumption, and ultimately impact BI Applicationsperformance.Oracle BI Applications customers are required to gather workload statistics on both source and target Oracledatabases prior to running initial ETL.Oracle recommends two options to gather system statistics:
-
Run the exec dbms_stats.gather_system_stats('start') procedure at the beginning of the workload window, 
    then the exec dbms_stats.gather_system_stats('stop') procedure at the end of the workload window.
-
Run exec dbms_stats.gather_system_stats('interval', interval=>10) where N is the number of minutes when statisticsgathering will be stopped automatically.


Important:
Execute dbms_stats.gather_system_stats, when the database is not idle. Oracle computes desired systemstatistics when database is under significant workload. Usually half an hour is sufficient to generate the valid statisticvalues


 exec DBMS_STATS.IMPORT_SCHEMA_STATS ( ownname => 'R0_APPPRD', stattab => 'STATS_DBA', statown => 'RO_APPPRD' );
exec DBMS_STATS.DROP_STAT_TABLE (   ownname => 'STCR_APPPRD',stattab => 'STATS_DBA');
exec dbms_stats.create_stat_table(ownname => 'STCR_APPPRD',stattab => 'STATS_DBA');
exec DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => 'RO_APPPRD', stattab => 'STATS_DBA', statown => 'RO_APPPRD' );
exec dbms_stats.create_stat_table(ownname => 'STCR_APPPRD',stattab => 'STATS_DBA1');
exec DBMS_STATS.IMPORT_SCHEMA_STATS ( ownname => 'R0_APPPRD', stattab => 'STATS_DBA', statown => 'RO_APPPRD' );
DBMS_STATS.DELETE_SCHEMA_STATS (ownname => 'SL_APPPRD');
DBMS_STATS.DELETE_TABLE_STATS (ownname => 'STCR_APPPRD', tabname => 'STCRMTB010P');


exec DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => 'RCG_APPPRD', stattab => 'STATS_DBA1', statown => 'RCG_APPPRD' );


SQL> exec DBMS_STATS.IMPORT_SCHEMA_STATS ( ownname => 'R0_APPPRD', stattab => 'STATS_DBA', statown => 'RO_APPPRD' );
BEGIN DBMS_STATS.IMPORT_SCHEMA_STATS ( ownname => 'R0_APPPRD', stattab => 'STATS_DBA', statown => 'RO_APPPRD' ); END;

*
ERROR at line 1:
ORA-20000: Schema R0_APPPRD does not exist or insufficient privileges to
analyze an object within it
ORA-06512: at "SYS.DBMS_STATS", line 4952
ORA-06512: at "SYS.DBMS_STATS", line 4975
ORA-06512: at "SYS.DBMS_STATS", line 5491
ORA-06512: at line 1

exec DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'RO_APPPRD', estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL INDEXED COLUMNS SIZE AUTO',degree => 20, granularity => 'DEFAULT', cascade => TRUE);

exec DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'RACSDWHMAN', estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL INDEXED COLUMNS SIZE AUTO',degree => 20, granularity => 'DEFAULT', cascade => TRUE);

exec DBMS_STATS.DROP_STAT_TABLE (   ownname => 'OPNET_APPPRD_1',stattab => 'STE');
exec dbms_stats.create_stat_table(ownname => 'STCR_APPPRD',stattab => 'STCRSTB061P_SAVE_STATS');
exec DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => 'OPNET_APPPRD_1', stattab => 'STE', statown => 'OPNET_APPPRD_1' );
exec DBMS_STATS.EXPORT_TABLE_STATS ( ownname => 'STST_APPPRD', stattab => 'STATS_DBA', statown => 'STST_APPPRD', TABNAME => 'STROWTB003N');
exec DBMS_STATS.IMPORT_TABLE_STATS ( ownname => 'STST_APPPRD', stattab => 'STATS_DBA', statown => 'STST_APPPRD', TABNAME => 'STROWTB003N');

exec dbms_stats.gather_table_stats(ownname=> 'STCR_APPPRD' , estimate_percent => 20, cascade => true, granularity => 'GLOBAL' , block_sample=> TRUE, method_opt => 'FOR ALL COLUMNS SIZE AUTO',tabname => 'STCRMTB040P');
exec dbms_stats.gather_table_stats(ownname=> 'STCR_APPPRD' , estimate_percent => 20, cascade => true, granularity => 'GLOBAL' , block_sample=> TRUE, method_opt => 'FOR ALL COLUMNS SIZE AUTO',tabname => 'STCRMTB010P');
 

exec dbms_stats.import_schema_stats('OPNET_APPPRD_1','STE');
exec DBMS_STATS.EXPORT_TABLE_STATS ( ownname => 'SL_APPPRD', stattab => 'STATS_DBA_LUCA', statown => 'SL_APPPRD', TABNAME => 'SLWTB064N');


exec DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'SL_APPPRD', estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL INDEXED COLUMNS SIZE AUTO',degree => 20, granularity => 'DEFAULT', cascade => TRUE);
exec DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'AN_APPPRD', estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL INDEXED COLUMNS SIZE AUTO',degree => 20, granularity => 'DEFAULT', cascade => TRUE);
exec dbms_stats.import_schema_stats('OPNET_APPPRD_1','STE');


exec DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'RACRORMAN', cascade => TRUE);

exec DBMS_STATS.GATHER_DATABASE_STATS (ownname => 'AN_APPPRD', estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL INDEXED COLUMNS SIZE AUTO',degree => 20, granularity => 'DEFAULT', cascade => TRUE);

exec DBMS_STATS.GATHER_TABLE_STATS (ownname => 'AL_APPPRD', tabname => 'ROTB111N',estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL INDEXED COLUMNS SIZE AUTO',degree => 20, granularity => 'DEFAULT', cascade => TRUE);
exec DBMS_STATS.GATHER_TABLE_STATS (ownname => 'RO_APPPRD', tabname => 'ROTB031N',estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL  COLUMNS SIZE AUTO',degree => 20, granularity => 'DEFAULT', cascade => TRUE);


exec DBMS_STATS.GATHER_INDEX_STATS (ownname => 'SL_APPPRD', indname => 'SLWTB064N_DBA3',estimate_percent => 20);

exec dbms_stats.gather_table_stats(ownname=> 'PO_APPPRD', tabname=> 'POTB165N', partname=> NULL,cascade => true);
exec DBMS_STATS.DELETE_TABLE_STATS (ownname => 'PO_APPPRD', TABNAME => 'POTB134N');
exec DBMS_STATS.DELETE_TABLE_STATS (ownname => 'STST_APPPRD', TABNAME => 'STROWTB003N');

exec DBMS_STATS.GATHER_SCHEMA_STATS(ownname => 'STST_APPPRD', estimate_percent => 20, block_sample=> TRUE,degree => 20, granularity => 'DEFAULT', cascade => TRUE);

exec DBMS_STATS.EXPORT_SCHEMA_STATS (ownname => 'RA_APPPRD', stattab => 'STATS_DBA', statown => 'RA_APPPRD' );


Schema  does not exist or insufficient privileges to analyze an object within it

_____________________________________________________________________________
______________ gather auto __________________________________________________
_____________________________________________________________________________

	There are several values for the options parameter that we need to know about:
	* gather – re-analyzes the whole schema.
	* gather empty – Only analyze tables that have no existing statistics.
	* gather stale – Only re-analyze tables with more than 10% modifications (inserts,updates, deletes).
	* gather auto – This will re-analyze objects which currently have no statistics and objects with stale statistics. Using gather auto is like combining gather stale and gather empty.

Note that both gather stale and gather auto require monitoring. If you issue the “alter table xxx
monitoring” command, Oracle tracks changed tables with the dba_tab_modifications view. Below
we see that the exact number of inserts, updates and deletes are tracked since the last analysis of
statistics.

		09-MAY-08 16:30:47 GMT
		
		.
		UPDATE
		=======
		Hi Stefano,
		
		Thanks for updating the SR.
		
		The MONITORING flag is dependant of the STATISTICS_LEVEL parameter. When STATISTICS_LEVEL is set to T
		YPICAL or ALL, the MONITORING flag is set to YES.
		
		When STATISTICS_LEVEL is set to BASIC, the MONITORING flag is set to NO (disabled).


set timing on
exec DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'STCR_APPPRD', estimate_percent => 10, block_sample=> TRUE, method_opt => 'FOR ALL COLUMNS SIZE AUTO',degree => 8, granularity => 'ALL', cascade =>TRUE,options => 'GATHER AUTO');

select partition_name,num_rows,to_char(last_analyzed,'DD-MM-YYYY HH24:MI:SS') from DBA_tab_partitions
where table_owner like 'STCR_APPPRD' and table_name like 'STCRMTB010P';

Elapsed: 00:02:09.96


++++++++++++++++++++++++++++++++++++++
-- stal
++++++++++++++++++++++++++++++++++++++
 	select PARTITION_NAME
	from dba_tab_statistics where owner = 'STCR_APPPRD'
	and table_name in (
	'STCRMTB010P',
 'STCRMTB087N',
 'STCRMTB136N',
 'STCRMTB640N'
 	)
 	and stale_stats = 'YES'
 	and PARTITION_NAME in ('STCRMTB010_20110114_PT','STCRMTB010_20110117_PT')
			 ;



-----------------------------------------------------------------



On Production 
1) Gather stats by using dbms_stats.gather_schema_stats 
2) exec dbms_stats.create_stat_table('RA_APPPRD','STATS_DBA');
exec dbms_stats.create_stat_table('RA_APPPRD','STATS_DBA_PRIMA');
exec dbms_stats.create_stat_table('AN_APPPRD','STATS_DBA_PRIMA');
3) exec dbms_stats.export_schema_stats('RA_APPPRD','STATS_DBA');
exec dbms_stats.export_schema_stats('AN_APPPRD','STATS_DBA');
At OS prompt:
%exp RO_APPPRD/passwd tables=STATS_dba_ORACLE file=expstat.dmp


On Test:
1) Copy expstat.dmp to test machine. 
2) %imp RO_APPRD/passwd file=expstat.dmp full=y log=implog.txt 
3) Open in sql*plus session and loagin as RO_APPPRD user
3) exec dbms_stats.import_schema_stats('RA_APPPRD','STATS_DBA');
exec dbms_stats.import_schema_stats('OPNET_APPPRD_1','STE');
exec dbms_stats.import_schema_stats('TR_APPPRD','STATS_DBA');
exec dbms_stats.import_schema_stats('AN_APPPRD','STATS_DBA');

exec DBMS_STATS.IMPORT_SCHEMA_STATS ( ownname => 'OPNET_APPPRD_1', stattab => 'STE', statown => 'OPNET_APPPRD_1' );

More Information Metalink 117203.1 


---------------------------------

exp ro_appprd/ro_appprd file=ro_appprd_with_errors.dmp tables=STATS_DBA
exp ra_appprd/ra_appprd file=ra_appprd_with_errors.dmp tables=STATS_DBA



___________________ procedura da usare sempre 


--######### Premessa 
-- da lanciaire la prima volta per creare la tabella delle stats

begin
  dbms_stats.create_stat_table(ownname => 'STE' ,stattab => 'STATS_DBA');
end;
/
--########## CAMPIONAMENTO STATS 
--############## ogni volta che gira mantiene l'ultima versione 
-- deve girare ogni notte
begin
  DBMS_STATS.DROP_STAT_TABLE ( ownname => 'STE' ,stattab => 'STATS_DBA');
  dbms_stats.create_stat_table(ownname => 'STE' ,stattab => 'STATS_DBA');
  DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => 'STE', stattab => 'STATS_DBA', statown => 'STE' );
  DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'STE', estimate_percent => 20, block_sample=> TRUE, method_opt => 'FOR ALL COLUMNS SIZE AUTO',degree => 8, granularity => 'ALL', cascade =>TRUE,options => 'GATHER AUTO');
end;
/

--########## RESTORE VECCHIE STAS 
--############## ogni volta che gira mantiene l'ultima versione 
begin
   DBMS_STATS.DELETE_SCHEMA_STATS ( ownname => 'STE' );
  EXEC DBMS_STATS.IMPORT_SCHEMA_STATS ( ownname => 'STE' , stattab => 'STATS_DBA', statown => 'STE'  );
end;
/

 !!! ricordarsi che se si mettonon in GRID Control bisogna togliere "exec"


========================================================================================================
========================================================================================================
========================================================================================================
 
 
_______________  per mettere nel GRID  _________________________ 
-- schedula un job con le in base alle stats con GATHER AUTO
-- viene messo in MAINTENANCE_WINDOW_GROUP che è una windows dalle 22.00 alle 6.00 dove fare manutenzione.
-- se il job non termina, viene killato in automatico.
BEGIN
sys.dbms_scheduler.create_job(
job_name => '"SYSTEM"."STATS_OPNET_APPPRD_1"',
job_type => 'PLSQL_BLOCK',
job_action => 'begin
  DBMS_STATS.DROP_STAT_TABLE ( ownname => ''OPNET_APPPRD_1'' ,stattab => ''STATS_DBA'');
  dbms_stats.create_stat_table(ownname => ''OPNET_APPPRD_1'' ,stattab => ''STATS_DBA'');
  DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => ''OPNET_APPPRD_1'', stattab => ''STATS_DBA'', statown => ''OPNET_APPPRD_1'' );
  DBMS_STATS.GATHER_SCHEMA_STATS (ownname => ''OPNET_APPPRD_1'', estimate_percent => dbms_stats.auto_sample_size, block_sample=> TRUE, method_opt => ''FOR ALL COLUMNS SIZE AUTO'',degree => 2, granularity => ''ALL'', cascade =>TRUE,options => ''GATHER AUTO'');
end;
',
schedule_name => '"SYS"."MAINTENANCE_WINDOW_GROUP"',
job_class => '"DEFAULT_JOB_CLASS"',
auto_drop => FALSE,
enabled => TRUE);
end;
/
--
exec sys.dbms_scheduler.set_attribute( name => '"SYSTEM"."STATS_OPNET_APPPRD_1"', attribute => 'job_weight', value => 1);
exec sys.dbms_scheduler.set_attribute( name => '"SYSTEM"."STATS_OPNET_APPPRD_1"', attribute => 'stop_on_window_close', value => TRUE);
exec sys.dbms_scheduler.set_attribute( name => '"SYSTEM"."STATS_OPNET_APPPRD_1"', attribute => 'restartable', value => TRUE);
exec sys.dbms_scheduler.enable( '"SYSTEM"."STATS_OPNET_APPPRD_1"' );
exec sys.dbms_scheduler.set_attribute( name => '"SYSTEM"."STATS_OPNET_APPPRD_1"', attribute => 'instance_stickiness', value => FALSE); 



###
######	  windows
###


 MAINTENANCE_WINDOW_GROUP Window Group    WEEKEND_WINDOW+ WEEKNIGHT_WINDOW
 WEEKEND_WINDOW Window 
 WEEKNIGHT_WINDOW Window 



  exec DBMS_STATS.DROP_STAT_TABLE ( ownname => 'OPNET_APPPRD_1' ,stattab => 'STATS_DBA');
  exec dbms_stats.create_stat_table(ownname => 'OPNET_APPPRD_1' ,stattab => 'STATS_DBA');
  exec DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => 'OPNET_APPPRD_1', stattab => 'STATS_DBA', statown => 'OPNET_APPPRD_1' );
  exec DBMS_STATS.GATHER_SCHEMA_STATS (ownname => 'OPNET_APPPRD_1', estimate_percent => dbms_stats.auto_sample_size, block_sample=> TRUE, granularity => 'ALL', method_opt => 'FOR ALL COLUMNS SIZE AUTO',degree => 2,  cascade =>TRUE,options => 'GATHER AUTO' );  

              options => 'GATHER AUTO'
              granularity=> 'ALL');
              
              
              
__________________ stats lanciate in parallelo ________________

***
******************   campionamento 71P partizioni < 2008 ****************************
***
set line 300
set pagesize 0
spool ste1.log

	select 'exec dbms_stats.gather_table_stats(ownname=> ''STCR_APPPRD'' , estimate_percent => dbms_stats.auto_sample_size , cascade => true , block_sample=> TRUE, method_opt => ''FOR ALL INDEXED COLUMNS SIZE 1'',granularity=> ''ALL'', degree => 1,tabname => ''' || table_name  ||''',partname => ''' || PARTITION_NAME  ||''');'
	from dba_tab_partitions where table_owner = 'STCR_APPPRD' 
	and table_name like 'ST%P'  
	and table_name  in (
	'STCRMTB071P')
	and partition_name not  like '%2008%' ;
spool off;

***
*******************   dimezzo file output per 2006 e 2007 ********************
***
wc -l ste1.log


split -l 60  ste1.log

ls x* | while read aa 
do
mv $aa $aa.sql
done


ls x*.sql | while read aa 
do
sqlplus system/nettuno77 @$aa &
done

ls xa[d-f].sql | while read aa 
do
sqlplus system/nettuno77@stdwhcol1 @$aa &
done

__________________________ query controllo stats _____________________

--table part
	select to_char(last_analyzed,'DD-MM-YYYY HH24:MI'),PARTITION_NAME,num_rows
	from dba_tab_partitions where table_owner = 'MHMH_APPPRD' 
	and table_name  in ('MHMHDT060P')
	--and partition_name   like '%20100111%'
	--and last_analyzed is  not   null
		order by  to_date(last_analyzed,'DD-MM-YYYY HH24:MI') asc ;


	select to_char(last_analyzed,'DD-MM-YYYY HH24:MI'),PARTITION_NAME,num_rows
	from dba_ind_partitions 
	where index_name in (select index_name from dba_tables table_owner = 'MHMH_APPPRD' 
	and table_name  in ('MHMHDT030P'))
		order by  to_date(last_analyzed,'DD-MM-YYYY HH24:MI') asc ;



--table
	select table_name,to_char(last_analyzed,'DD-MM-YYYY HH24:MI'),num_rows
	from dba_tables where owner = 'RCG_APPPRD' 
		and last_analyzed is  not   null
		--group by trunc(last_analyzed) order by trunc(last_analyzed)
		 ;
	
	
select trunc(last_analyzed),count(*)
 from dba_tables where owner = 'MHOP_APPPRD' 
and last_analyzed is  not   null
group by trunc(last_analyzed) 
order by trunc(last_analyzed) desc
 ;
		 	 
-- table part
	select to_char(last_analyzed),count(*)
	from dba_tab_partitions where table_owner = 'RCG_APPPRD'
	  and  table_name  in ('STCRMTB040P') 
		group by to_char(last_analyzed)
		order by to_char(last_analyzed) desc
	;
-- table 
	select to_char(last_analyzed),count(*),sum(num_rows),sum(sample_size)
	from dba_tables where owner like  '%_APPPRD%' 
 group by to_char(last_analyzed)
	;
	



______________________________ lock table _______________________

***
********************* carico stats dopo caricamento Bestia ***********
***
cd /bidone/STE/CORINTO
imp system/nettuno77@s1prd file=STATS_DBA_PRIMA_DROP_LUCA.dmp fromuser=stcr_appprd touser=stcr_appprd ignore=y

set timing on
--exec DBMS_STATS.DELETE_SCHEMA_STATS (ownname => 'STCR_APPPRD'); --Elapsed: 00:47:21.59

exec DBMS_STATS.IMPORT_SCHEMA_STATS ( ownname => 'STCR_APPPRD', stattab => 'STATS_DBA_DA_TENERE', statown => 'STCR_APPPRD'); --Elapsed: 00:29:48.19

-- generare script - le where sono sopra  (lock part < 2008) !! e' un rafforcativo !!
dbms_stats.lock_table_stats(ownname=> 'STCR_APPPRD', tabname=> 'XXXXX' );


exec dbms_stats.gather_schema_stats(
              ownname=> 'STCR_APPPRD' ,
              estimate_percent => dbms_stats.auto_sample_size,
              cascade => true ,
              degree => 8, block_sample=> TRUE,
              method_opt => 'FOR ALL INDEXED COLUMNS SIZE AUTO',
              options => 'GATHER AUTO'
              granularity=> 'ALL');"

_____________ BLOCK __________________

SELECT SEGMENT_NAME, SEGMENT_TYPE, OWNER FROM SYS.DBA_EXTENTS WHERE
&1 BETWEEN BLOCK_ID AND BLOCK_ID + BLOCKS - 1;
             
              
______________________ procedura per salvo stats _______________

***
********************* salvo le stat  appena fatto  *****
***  

exec DBMS_STATS.DROP_STAT_TABLE (   ownname => 'STCR_APPPRD',stattab => 'STATS_DBA_DA_TENERE');
exec dbms_stats.create_stat_table(ownname => 'STCR_APPPRD',stattab => 'STATS_DBA_DA_TENERE');
exec DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => 'STCR_APPPRD', stattab => 'STATS_DBA_DA_TENERE', statown => 'STCR_APPPRD');
!exp system/nettuno77@s1prd file=/bidone/STE/CORINTO/STATS_DBA_DA_TENERE.dmp tables=STCR_APPPRD.STATS_DBA_DA_TENERE

exec dbms_stats.create_stat_table(ownname => 'STCR_APPPRD',stattab => 'STATS_DBA_DA_TENERE_3005');

exec DBMS_STATS.EXPORT_SCHEMA_STATS ( ownname => 'STCR_APPPRD', stattab => 'STATS_DBA_DA_TENERE_3005', statown => 'STCR_APPPRD');
!exp system/nettuno77@s1prd file=/bidone/STE/CORINTO/STATS_DBA_DA_TENERE.dmp tables=STCR_APPPRD.STATS_DBA_DA_TENERE_3005

select SID, START_TIME,TOTALWORK, sofar, (sofar/totalwork) * 100 done,
sysdate + TIME_REMAINING/3600/24 end_at
 FROM gv$session_longops
     WHERE 
     opname NOT LIKE '%aggregate%'
     AND totalwork != 0
     AND sofar <> totalwork
/

-- giordani 16/06/2011 10.30.17
set lines 333
col opname for a28
col target for a30
col time_remaining for a14
col elapsed_so_far for a14
select sid, opname, target, start_time, last_update_time,
trunc(time_remaining/3600)||'h '||trunc(mod(time_remaining,3600)/60)||'m '||mod(time_remaining,60)||'s' time_remaining, trunc(elapsed_seconds/3600)||'h '||trunc(mod(elapsed_seconds,3600)/60)||'m '||mod(elapsed_seconds,60)||'s' elapsed_so_far
from gv$session_longops where (nvl(time_remaining,0) > 0) or(nvl(totalwork,0) > 0 and nvl(sofar,0) < nvl(totalwork,0))
order by sid;




set line 22222
col MESSAGE for a90
SELECT sid,inst_id,message,round(sofar/totalwork*100,2) "% Complete"
     FROM gv$session_longops
     WHERE 
     opname NOT LIKE '%aggregate%'
     AND totalwork != 0
     AND sofar <> totalwork
     order by 1
      /

--- monitor RMAN JOB ----  Metalink Note:144640.1

 SELECT sid, serial#, context, sofar, totalwork,
            round(sofar/totalwork*100,2) "% Complete"
     FROM gv$session_longops
     WHERE opname LIKE 'RMAN%'
     AND opname NOT LIKE '%aggregate%'
     AND totalwork != 0
     AND sofar <> totalwork
     /
           
REM RMAN Progress
alter session set nls_date_format='dd/mm/yy hh24:mi:ss'
/
select SID, START_TIME,TOTALWORK, sofar, (sofar/totalwork) * 100 done,
sysdate + TIME_REMAINING/3600/24 end_at
from v$session_longops
where totalwork > sofar
AND opname NOT LIKE '%aggregate%'
AND opname like 'RMAN%'
/

REM RMAN wiats
set lines 120
column sid format 9999
column spid format 99999
column client_info format a25
column event format a30
column secs format 9999
SELECT SID, SPID, CLIENT_INFO, event, seconds_in_wait secs, p1, p2, p3
  FROM V$PROCESS p, V$SESSION s
  WHERE p.ADDR = s.PADDR
  and CLIENT_INFO like 'rman channel=%'
/              	              


__________ STATS ____ End





____________________ TABLESPACE USAGE ______________

column "Tablespace" format a40


select
fs.tablespace_name "Tablespace",
(df.totalspace - fs.freespace) "Used MB",
fs.freespace "Free MB",
df.totalspace "Total MB",
round(100 * (fs.freespace / df.totalspace)) "Pct. Free"
from
(select
tablespace_name,
round(sum(bytes) / 1048576) TotalSpace
from
dba_data_files
group by
tablespace_name
) df,
(select
tablespace_name,
round(sum(bytes) / 1048576) FreeSpace
from
dba_free_space
group by
tablespace_name
) fs
where
df.tablespace_name = fs.tablespace_name
order by 2;
















_________ TRACE ____

set head off
set feed off
set echo off
spool start.log
select 'exec dbms_support.START_TRACE_IN_SESSION(' ||  vs.SID || ',' || vs.serial# ||',waits=>TRUE, binds=>FALSE);'
from v$session vs
where vs.username like 'INF%' 
;
spool off;

spool stop.log
select 'exec dbms_support.STOP_TRACE_IN_SESSION(' ||  vs.SID || ',' || vs.serial# ||');'
from v$session vs, v$process vp
from v$session vs
where vs.username like 'INF%' 
spool off;
set feed on
@start.log

exec dbms_support.START_TRACE_IN_SESSION('141','15948',waits=>TRUE, binds=>FALSE);
exec dbms_support.START_TRACE_IN_SESSION('147','54510',waits=>TRUE, binds=>FALSE);

exec sys.dbms_support.START_TRACE();
..
exec sys.dbms_support.stop_TRACE();

____ PARALLEL SERVER ____

SELECT QCSID, SID, INST_ID "Inst",  
  SERVER_GROUP "Group", SERVER_SET "Set",
  DEGREE "Degree", REQ_DEGREE "Req Degree"
FROM GV$PX_SESSION ORDER BY QCSID, QCINST_ID, SERVER_GROUP, SERVER_SET;

	QCSID      SID        Inst       Group      Set        Degree     Req Degree 
	---------- ---------- ---------- ---------- ---------- ---------- ---------- 
	         9          9          1 
	         9          7          1          1          1          2          2 
	         9         21          1          1          1          2          2 
	         9         18          1          1          2          2          2 
	         9         20          1          1          2          2          2 
	         
	         
	         
SELECT * FROM v_$px_process_sysstat;
	                 
SELECT * FROM gV$PX_PROCESS;   

	SERV STATUS    PID    SPID      SID    SERIAL 
	---- --------- ------ --------- ------ ------ 
	P002 IN USE        16     16955     21   7729 
	P003 IN USE        17     16957     20   2921 
	P004 AVAILABLE     18     16959              
	P005 AVAILABLE     19     16962             
	P000 IN USE        12      6999     18   4720 
	P001 IN USE        13      7004      7    234      

The first SQL statement extracts the mapping of Query Co-coordinator with parallel slaves along with state of parallel slaves, degree of parallelism, wait event that parallel slaves are waiting for, if any. 
	
col username for a12
col "QC SID" for A6
col "SID" for A6
col "QC/Slave" for A8
col "Req. DOP" for 9999
col "Actual DOP" for 9999
col "Slaveset" for A8
col "Slave INST" for A9
col "QC INST" for A6
set pages 300 lines 300
col wait_event format a30
select
decode(px.qcinst_id,NULL,username,
' - '||lower(substr(pp.SERVER_NAME,
length(pp.SERVER_NAME)-4,4) ) )"Username",
decode(px.qcinst_id,NULL, 'QC', '(Slave)') "QC/Slave" ,
to_char( px.server_set) "SlaveSet",
to_char(s.sid) "SID",
to_char(px.inst_id) "Slave INST",
decode(sw.state,'WAITING', 'WAIT', 'NOT WAIT' ) as STATE,    
case  sw.state WHEN 'WAITING' THEN substr(sw.event,1,30) ELSE NULL end as wait_event ,
decode(px.qcinst_id, NULL ,to_char(s.sid) ,px.qcsid) "QC SID",
to_char(px.qcinst_id) "QC INST",
px.req_degree "Req. DOP",
px.degree "Actual DOP"
from gv$px_session px,
gv$session s ,
gv$px_process pp,
gv$session_wait sw
where px.sid=s.sid (+)
and px.serial#=s.serial#(+)
and px.inst_id = s.inst_id(+)
and px.sid = pp.sid (+)
and px.serial#=pp.serial#(+)
and sw.sid = s.sid 
and sw.inst_id = s.inst_id  
order by
  decode(px.QCINST_ID,  NULL, px.INST_ID,  px.QCINST_ID),
  px.QCSID,
  decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
  px.SERVER_SET,
  px.INST_ID
/

The second SQL statement monitor and extracts information about the parallel processes waiting on wait events starting with ‘PX Deq’.

set pages 300 lines 300
col wait_event format a30
select
  sw.SID as RCVSID,
  decode(pp.server_name,
         NULL, 'A QC',
        pp.server_name) as RCVR,
  sw.inst_id as RCVRINST,
case  sw.state WHEN 'WAITING' THEN substr(sw.event,1,30) ELSE NULL end as wait_event ,
  decode(bitand(p1, 65535),
         65535, 'QC',
         'P'||to_char(bitand(p1, 65535),'fm000')) as SNDR,
  bitand(p1, 16711680) - 65535 as SNDRINST,
  decode(bitand(p1, 65535),
         65535, ps.qcsid,
         (select
            sid
          from
            gv$px_process
          where
            server_name = 'P'||to_char(bitand(sw.p1, 65535),'fm000') and
            inst_id = bitand(sw.p1, 16711680) - 65535)
       ) as SNDRSID,
   decode(sw.state,'WAITING', 'WAIT', 'NOT WAIT' ) as STATE    
from
  gv$session_wait sw,
  gv$px_process pp,
  gv$px_session ps
where
  sw.sid = pp.sid (+) and
  sw.inst_id = pp.inst_id (+) and
  sw.sid = ps.sid (+) and
  sw.inst_id = ps.inst_id (+) and
  p1text  = 'sleeptime/senderid' and
  bitand(p1, 268435456) = 268435456
order by
  decode(ps.QCINST_ID,  NULL, ps.INST_ID,  ps.QCINST_ID),
  ps.QCSID,
  decode(ps.SERVER_GROUP, NULL, 0, ps.SERVER_GROUP),
  ps.SERVER_SET,
  ps.INST_ID
/

This SQL statement will show the actual progress in terms of work allocated to the parallel slave and the amount of work still to be completed by those parallel slaves.

Select
decode(px.qcinst_id,NULL,username,
' - '||lower(substr(pp.SERVER_NAME,
length(pp.SERVER_NAME)-4,4) ) )"Username",
decode(px.qcinst_id,NULL, 'QC', '(Slave)') "QC/Slave" ,
to_char( px.server_set) "SlaveSet",
to_char(px.inst_id) "Slave INST",
substr(opname,1,30)  operation_name,
substr(target,1,30) target,
sofar,
totalwork,
units,
start_time,
timestamp,
decode(px.qcinst_id, NULL ,to_char(s.sid) ,px.qcsid) "QC SID",
to_char(px.qcinst_id) "QC INST"
from gv$px_session px,
gv$px_process pp,
gv$session_longops s
where px.sid=s.sid
and px.serial#=s.serial#
and px.inst_id = s.inst_id
and px.sid = pp.sid (+)
and px.serial#=pp.serial#(+)
order by
  decode(px.QCINST_ID,  NULL, px.INST_ID,  px.QCINST_ID),
  px.QCSID,
  decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
  px.SERVER_SET,
  px.INST_ID
/


Select
decode(px.qcinst_id,NULL,username,
' - '||lower(substr(pp.SERVER_NAME,
length(pp.SERVER_NAME)-4,4) ) )"Username",
to_char( px.server_set) "SlaveSet",
to_char(px.inst_id) "Slave INST",
substr(opname,1,10)  operation_name,
substr(target,1,10) target,
sofar,
totalwork,
units,
decode(px.qcinst_id, NULL ,to_char(s.sid) ,px.qcsid) "QC SID",
to_char(px.qcinst_id) "QC INST"
from gv$px_session px,
gv$px_process pp,
gv$session_longops s
where px.sid=s.sid
and px.serial#=s.serial#
and px.inst_id = s.inst_id
and px.sid = pp.sid (+)
and px.serial#=pp.serial#(+)
order by
  decode(px.QCINST_ID,  NULL, px.INST_ID,  px.QCINST_ID),
  px.QCSID,
  decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
  px.SERVER_SET,
  px.INST_ID
/


set line 132
SET NUMWIDTH 10
COLUMN STATE          FOR a7 tru
COLUMN EVENT          FOR a25 tru
COLUMN LAST_SQL FOR a40 tru
SELECT sw.inst_id INSTANCE,sw.sid SID, s.serial# SERIAL, sw.state STATE, sw.event EVENT,sw.seconds_in_wait SECONDS_WAITING, 
       sa.sql_text LAST_SQL,sa.sql_id SQL_ID
FROM gv$session_wait sw, gv$session s, gv$sqlarea sa
WHERE sw.event NOT IN ('rdbms ipc message','smon timer','pmon timer','SQL*Net message from client',
                               'lock manager wait for remote message','ges remote message','gcs remote message',
                               'gcs for action','client message','pipe get','null event','PX Idle Wait',
                               'single-talk message','Px Deq: Execution Msg','KXFQ: kxfqdeq - normal deqeue',
                               'listen endpoint status','slave wait','wakeup time manager')
AND sw.seconds_in_wait > 0
AND (sw.inst_id = s.inst_id AND sw.sid = s.sid)
AND (s.inst_id  = sa.inst_id AND s.sql_address = sa.address)
ORDER BY seconds_waiting DESC;


set line 132
SET NUMWIDTH 10
COLUMN STATE          FOR a7 tru
COLUMN EVENT          FOR a25 tru
SELECT sw.inst_id INSTANCE,sw.sid SID, sw.state STATE, sw.event EVENT,sw.seconds_in_wait SECONDS_WAITING
FROM gv$session_wait sw
WHERE  sw.seconds_in_wait > 0
ORDER BY seconds_waiting DESC;


_______________ lock

Questa query normalmente dovrebbe dare sempre 0
SELECT DECODE(G.INST_ID,1,'SSKY1',2,'SSKY2') INSTANCE,
S.SID,
G.TYPE,
S.USERNAME,
S.SERIAL#,
S.PROCESS,
DECODE(LMODE,0,'None',1,'Null',2,'Row-S',3,'Row-X',4,'Share',5,'S/ROW',
6,'Exclusive') LMODE,
DECODE(REQUEST,0,'None',1,'Null',2,'Row-S',3,'Row-X',4,'Share',
5,'S/ROW',6,'Exclusive')REQUEST,
DECODE(REQUEST,0,'BLOCKER','WAITER') STATE
FROM GV$GLOBAL_BLOCKED_LOCKS G,
GV$SESSION S
WHERE G.SID = S.SID
AND G.INST_ID = S.INST_ID
ORDER BY STATE






_________ EXPLAIN PLAN 

EXPLAIN PLAN FOR

select plan_table_output from table(dbms_xplan.display('plan_table',null,'serial'));


alter session set max_dump_file_size = unlimited;
ALTER SESSION SET EVENTS '10053 trace name context forever, level 1';
EXPLAIN PLAN FOR
..
;


explain plan set statement_id='1234' for 
DELETE /*+ INDEX(STCRMT_PLG_DDS_VERT,STCRMTB040P_IDX03)*/ STCR_APPPRD.STCRMT_PLG_DDS_VERT
 WHERE COD_SIST_PROV = 'MX90' 
 AND DTA_RIF = '29APR11' 
 AND (ORIGINE = 'Operazioni XCLIPCON' OR 'Operazioni XCLIPCON' = '*')
 AND (FILE_PROV = 'xclip_pl_06' OR 'xclip_pl_06' = '*')
 /

select cost,cpu_cost,bytes,cardinality from plan_table where statement_id = '1234';



_____ Trace optimizer__

 SQL> alter session set max_dump_file_size = unlimited;
  SQL> ALTER SESSION SET EVENTS '10053 trace name context forever, level 1';

  Session altered.

  SQL> EXPLAIN PLAN FOR --SQL STATEMENT--;

  Explained.

  SQL> exit




_____ Trace paralell

alter session set events '10384 trace name context forever, level 16384';
2. alter session set optimizer_features_enable='10.2.0.3';
3. <run your query>
4. alter session set events '10384 trace name context off';
5. exit


____TRACE___
alter session set tracefile_identifier='10046';   
alter session set timed_statistics = true;  
alter session set statistics_level=all;  
alter session set max_dump_file_size = unlimited;  
alter session set events '10046 trace name context forever,level 12';  
-- Execute the queries or operations to be traced here --  
select * from dual; 
 exit;


If the session is not exited then the trace can be disabled using:

  
alter session set events '10046 trace name context off';
  
  
____ TraCE ____

alter session set events '10046 trace name context forever, level 12';
alter session set max_dump_file_size = unlimited;
set timing on;
var B1 varchar2(255)
begin
:B1:='81168';
end;
/
	SELECT EXTISIN 
	FROM STCRST_PLG_POSIZIONE_MX90 
	WHERE (FAMILY, DEAL_TYPE, INSTR_TYPE, TIPO) 
	IN ( SELECT DISTINCT FAMILY, DEAL_TYPE, INSTR_TYPE, TIPO 
						FROM STCRMT_PLG_A_PRODOTTO 
						WHERE COD_PROD IN ('PROD2025', 'PROD2026', 'PROD2052', 'PROD2054') 
						AND sysdate-1 BETWEEN DTA_INIZ_VALID AND DTA_FINE_VALID) 
	AND CVM <> '0' AND CVM IS NOT NULL 
	AND EXTISIN IS NOT NULL 
	AND EXTISIN <> '*' AND 
	CVM = :B1 AND ROWNUM = 1;	
	
	
____ CPU/ESEC 
	 select inst_id,sql_id,hash_value,EXECUTIONS,CHILD_NUMBER,ROWS_PROCESSED,DISK_READS,BUFFER_GETS 
 from gv$sql where sql_id = 'f7dctcva90bp0'
 order by  buffer_gets;

	 select inst_id,sql_id,hash_value,EXECUTIONS,CHILD_NUMBER,ROWS_PROCESSED,DISK_READS,BUFFER_GETS 
 from gv$sql 
 order by  buffer_gets; 
 

 _____ BIND VARIABLE _____
col VALUE_STRING for a30
set line 120
SELECT 
--a.sql_text,
c.SID,
b.NAME,
b.POSITION,
b.datatype_string,
b.value_string
FROM v$sql_bind_capture b,
v$sqlarea a,
v$session c
WHERE b.sql_id = a.sql_id AND b.sql_id = c.sql_id AND c.SID = &1;




UKJA@ukja102>
UKJA@ukja102> var sql_id varchar2(100);
UKJA@ukja102> begin
  2    select sql_id into :sql_id
  3    from dba_hist_sqltext
  4    where sql_text like 'update t1 set c3 = :b3 where c1 between :b1 and :b2';
  5  end;
  6  /

PL/SQL procedure successfully completed.

UKJA@ukja102>
UKJA@ukja102> print sql_id

SQL_ID
--------------------------------------------------------------------------------
bvy5d4xupjkku


col name format a10
col position format 99
col value_string format a20
select snap_id, name, position, value_string, last_captured -
from dba_hist_sqlbind
where sql_id = sql_id
order by snap_id desc;

   SNAP_ID NAME       POSITION VALUE_STRING         LAST_CAPTURED
---------- ---------- -------- -------------------- -------------------
      6701 :B1               2 1                    2009/05/06 11:10:13
      6701 :B2               3 2000                 2009/05/06 11:10:13
      6701 :B3               1
      6700 :B2               3 1000                 2009/05/06 11:10:03
      6700 :B3               1
      6700 :B1               2 1                    2009/05/06 11:10:03
      6699 :B1               2 1                    2009/05/06 11:05:50
      6699 :B3               1
      6699 :B2               3 2000                 2009/05/06 11:05:50
      6697 :B2               3 2000                 2009/05/06 10:47:51
      6697 :B3               1
      6697 :B1               2 1                    2009/05/06 10:47:51  


26640 
26646 


col name format a10
col position format 99
col value_string format a40
select snap_id, name, position, value_string, to_char(last_captured,'DD-MM-YYYY HH24:MI')
from dba_hist_sqlbind
where sql_id = '2p2qstycghngh'
and snap_id between 26640 and 26646
and name like ':B4'
order by last_captured,snap_id desc;



col name format a10
col position format 99
col value_string format a40
select snap_id, name, position, value_string, to_char(last_captured,'DD-MM-YYYY HH24:MI')
from dba_hist_sqlbind
where sql_id = 'fa8a82kdccjf9'
order by last_captured,snap_id desc;



query to check dml operations done on that table for last 1 day

select
SAMPLE_ID,
to_char(SAMPLE_TIME,'DD/MM/YYYY HH24:MI:SS') ,
s.SQL_ID,
vs.SQL_FULLTEXT
from DBA_HIST_ACTIVE_SESS_HISTORY s , v$sqlstats vs
where trunc(SAMPLE_TIME) = trunc(sysdate)-1
and SQL_OPCODE not in ( 3,0)
and vs.sql_id = s.SQL_ID
and vs.SQL_FULLTEXT like '%<table name>%'



____ BUFFERE GETS
 select inst_id,sql_id,hash_value,EXECUTIONS,CHILD_NUMBER,ROWS_PROCESSED,DISK_READS,BUFFER_GETS 
 from gv$sql where sql_id = '5sxt6s0vg7kru'
 order by  buffer_gets;
 
 
  select inst_id,sql_id,hash_value,EXECUTIONS,CHILD_NUMBER,ROWS_PROCESSED,DISK_READS,BUFFER_GETS 
 from gv$sql  order by  buffer_gets;
  
  select inst_id,sql_id,hash_value,EXECUTIONS,CHILD_NUMBER,ROWS_PROCESSED,DISK_READS,BUFFER_GETS 
 from gv$sql 
 order by  DISK_READS;
 
 Example 7-1 Calculating the Buffer Cache Hit Ratio                                                                   
                                                                                                                      
 SELECT NAME, VALUE                                                                                                   
   FROM V$SYSSTAT                                                                                                     
 WHERE NAME IN ('db block gets from cache', 'consistent gets from cache', 'physical reads cache');                    
_                                                                                                                     __ rollback - How long will it take to rollback a transaction.pdf speed rollback
 Using the values in the output of the query, calculate the hit ratio for the buffer cache with the following formula:
S                                                                                                                     ELECT sid, serial#, context, sofar, totalwork,
r1 - (('physical reads cache') / ('consistent gets from cache' + 'db block gets from cache')                          ound(sofar/totalwork*100,2) "% Complete",message
FROM v$session_longops
WHERE sid = 120
; 

set lin 120
col OPNAME for a30
col units for a10
select v$session_longops.sid,OPNAME,SOFAR,TOTALWORK,UNITS            
from  v$session_longops , v$session 
where v$session_longops.sid = v$session.sid 
and v$session.status like 'ACTIVE' and  v$session.sid=228;
 
 
_____ gc cr request_
 select a.inst_id,a.sid, a.serial#, a.username, b.owner, b.object, b.type
from   gv$session a, gv$access b
where  a.inst_id=b.inst_id and a.sid = b.sid and b.type like 'TABL%' and b.OBJECT ='STCRSTB061N'
and OWNER='STCR_APPPRD';




ALTER  SESSION SET  EVENTS '10046 trace name context forever, level 8';



_________ LOAD _process ____
set line 222
col machine for a10;
col P1TEXT for a10;
col P2TEXT for a10;
col EVENT for a20
select s.sid,s.serial#,s.inst_id,s.process,
s.machine,s.last_call_et,s.status,w.event,w.P1,w.P1TEXT,W.P2,w.P2TEXT 
from gv$session s, gv$session_wait w
where s.sid = w.sid and s.inst_id = w.inst_id
--and s.sid=148;
--and s.process='342'
;

SELECT a.sid,c.sql_text
FROM v$session a, v$sqlarea c
where c.address= a.sql_address
and c.hash_value = a.sql_hash_value
and a.sid=138;
--and process='15045';


col category for a20
col name for a30
col SIGNATURE for 999999999999999999
set lines 222
select NAME,CATEGORY,SIGNATURE,CREATED,STATUS,FORCE_MATCHING from DBA_SQL_PROFILES


#### RAC RDBMS  CORINTO ####
 export DISPLAY=rrcobo01vp:1.0
 sleep 1;xterm -geometry 140x10-100+20   -T rrdbbo01fp -bg black -fg red          -e "ssh rrdbbo01fp tail -f /sw/oracle/admin/STDWHPRD/bdump/alert*log" &
 sleep 1;xterm -geometry 140x10-100+100  -T rrdbbo02fp -bg black -fg yellow       -e "ssh rrdbbo02fp tail -f /sw/oracle/admin/STDWHPRD/bdump/alert*log" &
 sleep 1;xterm -geometry 140x10-100+180  -T rrdbbo03fp -bg black -fg green        -e "ssh rrdbbo03fp tail -f /sw/oracle/admin/STDWHPRD/bdump/alert*log" &
 sleep 1;xterm -geometry 140x10-100+260  -T rrdbsc01fp -bg black -fg cyan         -e "ssh rrdbsc01fp tail -f /sw/oracle/admin/STDWHPRD/bdump/alert*log" &
 sleep 1;xterm -geometry 140x10-100+320  -T rrdbsc02fp -bg black -fg magenta      -e "ssh rrdbsc02fp tail -f /sw/oracle/admin/STDWHPRD/bdump/alert*log" &
 sleep 1;xterm -geometry 140x10-100+400  -T rrdbsc03fp -bg black -fg orange       -e "ssh rrdbsc03fp tail -f /sw/oracle/admin/STDWHPRD/bdump/alert*log" &




#### RAC CSSD ####
 export DISPLAY=wcab0767:0.0
 sleep 1;xterm -geometry 140x10-100+20   -T CSSrrdbbo01fp -bg black -fg red          -e "ssh rrdbbo01fp tail -f /sw/oracle/crs/log/rrdbbo01fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+100  -T CSSrrdbbo01fp -bg black -fg yellow       -e "ssh rrdbbo01fp tail -f /sw/oracle/crs/log/rrdbbo01fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+180  -T CSSrrdbbo01fp -bg black -fg green        -e "ssh rrdbbo01fp tail -f /sw/oracle/crs/log/rrdbbo01fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+260  -T CSSrrdbsc01fp -bg black -fg cyan         -e "ssh rrdbsc01fp tail -f /sw/oracle/crs/log/rrdbsc01fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+320  -T CSSrrdbsc02fp -bg black -fg magenta      -e "ssh rrdbsc02fp tail -f /sw/oracle/crs/log/rrdbsc02fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+400  -T CSSrrdbsc03fp -bg black -fg orange       -e "ssh rrdbsc03fp tail -f /sw/oracle/crs/log/rrdbsc03fp/cssd/ocssd.log" &


 #### RAC CRSD ####
export DISPLAY=wcab0767:0.0
 sleep 1;xterm -geometry 120x10-100+20   -T CRSrrdbbo01fp -bg black -fg red          -e "ssh rrdbbo01fp tail -f /sw/oracle/crs/log/rrdbbo01fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+100  -T CRSrrdbbo01fp -bg black -fg yellow       -e "ssh rrdbbo01fp tail -f /sw/oracle/crs/log/rrdbbo01fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+180  -T CRSrrdbbo01fp -bg black -fg green        -e "ssh rrdbbo01fp tail -f /sw/oracle/crs/log/rrdbbo01fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+260  -T CRSrrdbsc01fp -bg black -fg cyan         -e "ssh rrdbsc01fp tail -f /sw/oracle/crs/log/rrdbsc01fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+320  -T CRSrrdbsc02fp -bg black -fg magenta      -e "ssh rrdbsc02fp tail -f /sw/oracle/crs/log/rrdbsc02fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+400  -T CRSrrdbsc03fp -bg black -fg orange       -e "ssh rrdbsc03fp tail -f /sw/oracle/crs/log/rrdbsc03fp/crsd/crsd.log" &



 #### ASM CRSD ####
export DISPLAY=wcab0767.bancacaboto.dom:0.0
 sleep 1;xterm -geometry 120x10-100+20   -T CRSrrdbbo01fp -bg black -fg red          -e "ssh rrdbbo01fp tail -f /sw/oracle/diag/asm/+asm/+ASM*/trace/alert_+ASM*.log" &
 sleep 1;xterm -geometry 120x10-100+100  -T CRSrrdbbo01fp -bg black -fg yellow       -e "ssh rrdbbo01fp tail -f /sw/oracle/diag/asm/+asm/+ASM*/trace/alert_+ASM*.log" &
 sleep 1;xterm -geometry 120x10-100+180  -T CRSrrdbbo01fp -bg black -fg green        -e "ssh rrdbbo01fp tail -f /sw/oracle/diag/asm/+asm/+ASM*/trace/alert_+ASM*.log" &
 sleep 1;xterm -geometry 120x10-100+260  -T CRSrrdbsc01fp -bg black -fg cyan         -e "ssh rrdbsc01fp tail -f /sw/oracle/diag/asm/+asm/+ASM*/trace/alert_+ASM*.log" &
 sleep 1;xterm -geometry 120x10-100+320  -T CRSrrdbsc02fp -bg black -fg magenta      -e "ssh rrdbsc02fp tail -f /sw/oracle/diag/asm/+asm/+ASM*/trace/alert_+ASM*.log" &
 sleep 1;xterm -geometry 120x10-100+400  -T CRSrrdbsc03fp -bg black -fg orange       -e "ssh rrdbsc03fp tail -f /sw/oracle/diag/asm/+asm/+ASM*/trace/alert_+ASM*.log" &
 

 ### Sistema Operativo ####
 export DISPLAY=10.202.29.93:0.0
 sleep 1;xterm -geometry 120x10-25+20  -T SYSrrdbbo01fp -bg black -fg red     -e "ssh rrdbbo01fp tail -f /var/log/messages" &
 sleep 1;xterm -geometry 120x10-25+100 -T SYSrrdbbo01fp -bg black -fg yellow  -e "ssh rrdbbo02fp tail -f /var/log/messages"   &
 sleep 1;xterm -geometry 120x10-25+180 -T SYSrrdbbo01fp -bg black -fg green   -e "ssh rrdbbo03fp tail -f /var/log/messages"    &
 sleep 1;xterm -geometry 120x10-25+260 -T SYSrrdbsc01fp -bg black -fg cyan    -e "ssh rrdbsc01fp tail -f /var/log/messages"     &
 sleep 1;xterm -geometry 120x10-25+320 -T SYSrrdbsc02fp -bg black -fg magenta -e "ssh rrdbsc02fp tail -f /var/log/messages"  &
 sleep 1;xterm -geometry 120x10-25+400 -T SYSrrdbsc03fp -bg black -fg orange  -e "ssh rrdbsc03fp tail -f /var/log/messages"   &



________________ RAC SUPERSHELL - XTERM - ALERT.log
### Sistema Operativo  ADAPTER APPSERVER####
 export DISPLAY=10.202.29.93:0.0
 sleep 1;xterm -geometry 120x10-25+20  -T rradbo01fp -bg black -fg red     -e "ssh rradbo01fp tail -f /var/log/messages" &
 sleep 1;xterm -geometry 120x10-25+100 -T rradbo01fp -bg black -fg yellow  -e "ssh rradbo01fp tail -f /var/log/messages"   &
 sleep 1;xterm -geometry 120x10-25+180 -T rrapbo01fp -bg black -fg green   -e "ssh rrapbo01fp tail -f /var/log/messages"    &
 sleep 1;xterm -geometry 120x10-25+260 -T rrapsc01fp -bg black -fg cyan    -e "ssh rrapsc01fp tail -f /var/log/messages"     &


__________ NEW RAC _____

#### RAC CRSD ####
 export DISPLAY=10.202.29.93:0.0
 sleep 1;xterm -geometry 140x10-100+20   -T CSSrrdbbo05fp -bg black -fg red          -e "ssh rrdbbo05fp tail -f /sw/oracle/crs/log/rrdbbo05fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+100  -T CSSrrdbbo06fp -bg black -fg yellow       -e "ssh rrdbbo06fp tail -f /sw/oracle/crs/log/rrdbbo06fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+180  -T CSSrrdbsc05fp -bg black -fg green        -e "ssh rrdbsc05fp tail -f /sw/oracle/crs/log/rrdbsc05fp/cssd/ocssd.log" &
 sleep 1;xterm -geometry 140x10-100+260  -T CSSrrdbsc05fp -bg black -fg cyan         -e "ssh rrdbsc05fp tail -f /sw/oracle/crs/log/rrdbsc05fp/cssd/ocssd.log" &


 #### RAC CRSD ####
 export DISPLAY=10.202.29.93:0.0
 sleep 1;xterm -geometry 120x10-100+20   -T CRSrrdbbo05fp -bg black -fg red          -e "ssh rrdbbo05fp tail -f /sw/oracle/crs/log/rrdbbo05fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+100  -T CRSrrdbbo06fp -bg black -fg yellow       -e "ssh rrdbbo06fp tail -f /sw/oracle/crs/log/rrdbbo06fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+180  -T CRSrrdbsc05fp -bg black -fg green        -e "ssh rrdbsc05fp tail -f /sw/oracle/crs/log/rrdbsc05fp/crsd/crsd.log" &
 sleep 1;xterm -geometry 120x10-100+260  -T CRSrrdbsc05fp -bg black -fg cyan         -e "ssh rrdbsc05fp tail -f /sw/oracle/crs/log/rrdbsc05fp/crsd/crsd.log" &
 

 ### Sistema Operativo ####
 export DISPLAY=10.202.29.93:0.0
 sleep 1;xterm -geometry 120x10-25+20  -T SYSrrdbbo05fp -bg black -fg red     -e "ssh rrdbbo05fp tail -f /var/log/messages" &
 sleep 1;xterm -geometry 120x10-25+100 -T SYSrrdbbo06fp -bg black -fg yellow  -e "ssh rrdbbo06fp tail -f /var/log/messages"   &
 sleep 1;xterm -geometry 120x10-25+180 -T SYSrrdbsc05fp -bg black -fg green   -e "ssh rrdbsc05fp tail -f /var/log/messages"    &
 sleep 1;xterm -geometry 120x10-25+260 -T SYSrrdbsc05fp -bg black -fg cyan    -e "ssh rrdbsc05fp tail -f /var/log/messages"     &



 export DISPLAY=10.202.29.93:0.0
 sleep 1;xterm -geometry 140x10-100+20   -T CSSrrdbbo05fp -bg black -fg red          -e "ssh rrdbbo05fp " &
 sleep 1;xterm -geometry 140x10-100+100  -T CSSrrdbbo06fp -bg black -fg yellow       -e "ssh rrdbbo06fp " &
 sleep 1;xterm -geometry 140x10-100+180  -T CSSrrdbsc05fp -bg black -fg green        -e "ssh rrdbsc05fp " &
 sleep 1;xterm -geometry 140x10-100+260  -T CSSrrdbsc05fp -bg black -fg cyan         -e "ssh rrdbsc05fp " &



++++++++++++++++++++++++++++++++++++++
NMON
++++++++++++++++++++++++++++++++++++++

 #### ASM CRSD ####
export DISPLAY=wcab0767.bancacaboto.dom:0.0
 sleep 1;xterm -geometry 120x10-100+20   -T CRSrrdbbo01fp -bg black -fg red          -e "ssh rrdbbo01fp " &
 sleep 1;xterm -geometry 120x10-100+100  -T CRSrrdbbo02fp -bg black -fg yellow       -e "ssh rrdbbo02fp " &
 sleep 1;xterm -geometry 120x10-100+180  -T CRSrrdbbo03fp -bg black -fg green        -e "ssh rrdbbo03fp " &
 sleep 1;xterm -geometry 120x10-100+260  -T CRSrrdbsc01fp -bg black -fg cyan         -e "ssh rrdbsc01fp " &
 sleep 1;xterm -geometry 120x10-100+320  -T CRSrrdbsc02fp -bg black -fg magenta      -e "ssh rrdbsc02fp " &
 sleep 1;xterm -geometry 120x10-100+400  -T CRSrrdbsc03fp -bg black -fg orange       -e "ssh rrdbsc03fp " &




__________ OUTLINE 

create or replace outline OUT_SUPPORT_4t1u5rmwr5bdz on
query

exp "'/ as sysdba'" file=myoutln.dmp tables='outln.ol$,outln.ol$hints,outln.ol$nodes' query=\"where ol_name=\'OUT_SUPPORT_4t1u5rmwr5bdz\'\" statistics=n

imp "'/ as sysdba'" file=myoutln.dmp full=y ignore=y



___________ REPRODUCE TEST CASE - DBMS_SQLDIAG

How to create a SQL-testcase using the DBMS_SQLDIAG package [Video] (Doc ID 727863.1) 


Giuseppe De Santis [giuseppe.d.de.santis@oracle.com]

come creare un test case...attento che il parametro di default è esportare anche i dati...


1. Exporting the testcase

-------------------------- export_sql_testcase ------------------------
-- NAME:
-- export_sql_testcase
--
-- DESCRIPTION:
-- Export a SQL test case to a directory.
-- This API allow the SQL Testcase to be generated from a cursor
-- present in the cursor cache.
-- Use v$sql to get the SQL identifier and the SQL hash value.
--
--
-- PARAMETERS:
-- directory (IN) - directory to store the various generated files
-- sql_id (IN) - identifier of the statement in the cursor cache
-- plan_hash_value (IN) - plan hash value of a particula plan of the SQL
-- exportEnvironment (IN) - TRUE if the compilation environment should be
-- exported
-- exportMetadata (IN) - TRUE if the definition of the objects referenced
-- in the SQL should be exported.
-- exportData (IN) - TRUE if the data of the objects referenced
-- in the SQL should be exported.
-- exportPkgbody (IN) - TRUE if the body of the packages referenced
-- in the SQL should be exported.
-- samplingPercent (IN) - if exportData is TRUE, specify the sampling
-- percentage to use to create the dump file
-- ctrlOptions (IN) - opaque control parameters
-- timeLimit (IN) - how much time should we spend exporting the
-- SQL test case
-- testcaseName (IN) - an optional name for the SQL test case. This
-- is used to prefix all the generated scripts.
-- testcaseMetadata (OUT) - the resulting test case

---------------------------------------------------------------------------------------
--SQL> create directory exp_tc as '/tmp';
--
--declare
--  tc_out clob;
--begin
--   dbms_sqldiag.export_sql_testcase(directory=>'EXP_TC',
--                                    sql_id=>'6xsa7y7mtzmsx',
--                                    testcase => tc_out);
--end;
--/
---------------------------------------------------------------------------------------
Or using an SQL-statement :
---------------------------------------------------------------------------------------
--declare
--  tc_out clob;
--begin
--   dbms_sqldiag.export_sql_testcase(directory=>'EXP_TC',
--                                    sql_text=>'select count(*) from emp',
--                                    testcase => tc_out);
--end;
--/
---------------------------------------------------------------------------------------

Verifiche
---------------------------------------------------------------------------------------
--SQL> select directory_path
--     from DBA_DIRECTORIES
--     where directory_name='EXP_TC';
--
--% ls -al <directory_path>
--
---rw-r--r-- 1 oracle dba 1157 Jul 18 15:44 README.txt
---rw-r--r-- 1 oracle dba 1038 Jul 18 15:44 oratcb2_000E5EA00002sql.xml
---rw-r--r-- 1 oracle dba 438 Jul 18 15:44 oratcb2_000E5EA00002ol.xml
---rw-r--r-- 1 oracle dba 4506 Jul 18 15:44 oratcb2_000E5EA00002dpexp.sql
---rw-r--r-- 1 oracle dba 1060 Jul 18 15:44 oratcb2_000E5EA00002dpexp.log
---rw-r----- 1 oracle dba 188416 Jul 18 15:44 oratcb2_000E5EA00002dpexp.dmp
---rw-r--r-- 1 oracle dba 157 Jul 18 15:44 oratcb2_000E5EA00002xpl.txt
---rw-r--r-- 1 oracle dba 415 Jul 18 15:44 oratcb2_000E5EA00002xpls.sql
---rw-r--r-- 1 oracle dba 665 Jul 18 15:44 oratcb2_000E5EA00002xplo.sql
---rw-r--r-- 1 oracle dba 438 Jul 18 15:44 oratcb2_000E5EA00002xplf.sql
---rw-r--r-- 1 oracle dba 388 Jul 18 15:44 oratcb2_000E5EA00002ssimp.sql
---rw-r--r-- 1 oracle dba 1764 Jul 18 15:44 oratcb2_000E5EA00002main.xml
---rw-r--r-- 1 oracle dba 3764 Jul 18 15:44 oratcb2_000E5EA00002dpimp.sql
---------------------------------------------------------------------------------------

2. Importing the testcase in another database
---------------------------------------------------------------------------------------
--% cp oratcb2* <imp_tc-dir>
--
--SQL> connect / as sysdba
--     create directory imp_tc as '<imp_tc-dir>';
--     grant read on directory imp_tc to <user>;
--     grant write on directory imp_tc to <user>;
--
--     connect <user>/<password>
--     begin
--       dbms_sqldiag.import_sql_testcase(directory=>'IMP_TC',
--                             filename =>'oratcb2_000E5EA00002main.xml');
--     end;
--     /
---------------------------------------------------------------------------------------




_________________ OWB __________

set line 2222
col RTA_LOB_NAME for a30
select  RTA_LOB_NAME,to_char(CREATION_DATE,'DD-MM-YYYY HH24:MI'),trunc(RTA_ELAPSE/60)
FROM STCC_OWB102G.wb_rt_AUDIT where RTA_LOB_NAME like '%STCRDPKG_BT_DDS_BT_MX90%' 
--and TRUNC(RTA_ELAPSE/60) !=0
order by CREATION_DATE;
                                                                      
                                                                      
____________ RESIZE DATAFILE 

Knowledge Xpert for Oracle Administration > Instant Scripts > Object Management > Tablespaces and Datafiles > Reports > Script to Report Tablespace Map
Script to Report Tablespace Map

This script creates an extent map for the tablespace indicated.

Sample Output

Copy Script to Clipboard

REM LOCATION:   Object Management\Tablespaces and DataFiles\Reports
REM FUNCTION:   create an extent map for a specific tablespace
REM TESTED ON:  7.3.3.5, 8.0.4.1, 8.1.5, 8.1.7, 9.0.1, 10.2.0.3, 11.1.0.6 
REM PLATFORM:   non-specific
REM REQUIRES:   dba_free_space, dba_extents
REM
REM  This is a part of the Knowledge Xpert for Oracle Administration library.
REM  Copyright (C) 2008 Quest Software
REM  All rights reserved.
REM
REM ******************** Knowledge Xpert for Oracle Administration ********************



select tablespace_name from dba_tablespaces where tablespace_name like 'STCR%';

set line 200
col OBJECT for a70
drop table tbs_map;
create table tbs_map as 
SELECT   'free space' owner, '      ' OBJECT, file_id, block_id, blocks
    FROM dba_free_space
   WHERE tablespace_name = UPPER ('STCRTSBL0001D')
UNION
SELECT   SUBSTR (owner, 1, 20), SUBSTR (segment_name, 1, 32), file_id,
         block_id, blocks
    FROM dba_extents
   WHERE tablespace_name = UPPER ('STCRTSBL0001D')
ORDER BY 3, 4;         


select file_id,file_name from dba_data_files 
     where file_id in (
     																				select distinct(file_id) from tbs_map 
     																		)
      ;


        52 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d.281.749053879
        55 +DG_EVA_STDWHCOLL/stdwhcol/datafile/stcrtsbl0001d.374.751890833
       106 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.257.748724047
       108 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.258.748724399
       111 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.259.748724631
       112 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.260.748724857
       114 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.261.748725059
       115 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.262.748725317
       117 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.263.748725541
       121 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.264.748725739
       122 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.265.748725941
       148 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.266.748726181
       151 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.267.748726379
       152 +DG_EVA_STDWHCOLL1/stdwhcol/datafile/stcrtsbl0001d_new.268.748726577

 OWNER         
 OBJECT        
 FILE_ID       
 BLOCK_ID      
 BLOCKS        



select * from (
select * from tbs_map dba_data_files where file_id = 52 
order by block_id asc)
where rownum < 10;

drop table tbs_map;







__________ TABLE SIZE ________

select * from (
select segment_name,
segment_type, 
tablespace_name,
trunc(sum(bytes)/1024/1024)
from dba_segments
where  owner='%_APPPRD'
--and tablespace_name like 'STCRTSBL0001D'
--and segment_name  like 'STRCGDTB011P'
group by segment_name,tablespace_name,segment_type
order by trunc(sum(bytes)/1024/1024) desc 
)
where rownum < 10;



---- sql developers
                      select segment_name    "Table_Name", 
                                      tablespace_name "Tablespace", 
                                      bytes/1024/1024 "Megabytes"
                                 from user_segments
                                where segment_type = 'TABLE'
                                  and segment_name not like 'BIN$%'
                                order by segment_name, tablespace_name
                                
                                
##### HANGANALYZE 


<<Note:986640.1>> How To Connect Using A Sqlplus Preliminary Connection

Do this 2 times in 2 separate windows, creating 2 sqlplus sessions (SQL1 and SQL2) for each rac node
In SQL1 gather the hanganalyze by executing the following:

sqlplus -prelim / as sysdba /*nel caso non ci si colleghi con spdba*/

SQL1> oradebug setmypid
SQL1> oradebug unlimit;
SQL1> oradebug hanganalyze 3;

In SQL2 gather the systemstates by executing the following:

SQL2> oradebug setmypid
SQL2> oradebug unlimit;
SQL2> oradebug dump systemstate 266;

Gather a second hang analyze having waited at least 1 minute to give time to identify process state changes. In SQL1 execute the following:

SQL1> oradebug hanganalyze 3

In SQL2 execute the following to collect a second systemstate dump:

SQL2> oradebug setmypid
SQL2> oradebug unlimit;
SQL2> oradebug dump systemstate 266

++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++


Provide System Dump files WHILE you see the issue (hang)
==================

Next time you see the performance problem, do the following.

Note: 359536.1 - Systemstate dump when connection to the instance is not possible (Doc ID 359536.1)

Start a New SQLplus session
$ sqlplus '/ as sysdba'
set pages 10000
set linesize 120
spool /tmp/PIDList.txt

SELECT p.ADDR, p.PID, p.SPID, s.SID, s.SERIAL#, s.USERNAME
FROM V$PROCESS p, V$SESSION S
WHERE p.ADDR = s.PADDR ;
Quit


1) Provide trace dumps, while you see the hang.

Start a New SQLplus session
$ sqlplus '/ as sysdba'
oradebug setmypid
oradebug tracefile_name -->it will give you trace file name. Update the SR with this file name
oradebug unlimit
oradebug dump systemstate 258
Wait 30 seconds
oradebug dump systemstate 258
Wait 30 seconds
oradebug dump systemstate 258
Quit



Start a New SQLplus session
$ sqlplus '/ as sysdba'
oradebug setmypid
oradebug tracefile_name -->it will give you trace file name. Update the SR with this file name
oradebug unlimit
oradebug hanganalyze 3
Wait 30 seconds
oradebug hanganalyze 3
Wait 30 seconds
oradebug hanganalyze 3
Quit




2) Trace the hung session here:

Start a New SQLplus session
$ sqlplus '/ as sysdba'
oradebug setospid <Use Problem SPID>
oradebug tracefile_name -->it will give you trace file name. Update the SR with this file name
oradebug unlimit
oradebug dump errorstack 3
wait 3 seconds
oradebug dump errorstack 1
wait 3 seconds
oradebug dump errorstack 1
wait 3 seconds
oradebug dump errorstack 1
wait 3 seconds
oradebug dump errorstack 1
wait 3 seconds
Quit








++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++







##### ORADEBUG 

sql>oradebug setospid <ospid smon>
sql>oradebug unlimit
sql>oradebug dump errorstack 10
### Wait 1 minute
sql>oradebug dump errorstack 10
sql>oradebug tracefile_name


__________________ job 


select job_name,state,LAST_START_DATE,END_DATE  from user_scheduler_jobs where JOB_NAME like '%STA%' and STATE like 'BROKEN';

_______ Access 

col INST_ID for 99
col SID for 999
col USERNAME for a20
col OWNER for a20
col OBJECT for a20
col TYPE for a20
set lines 133
set pages 1500
select a.inst_id,a.sid, a.serial#, a.username, b.owner, b.object, b.type
from gv$session a, gv$access b
where a.inst_id=b.inst_id and a.sid = b.sid and b.type like '%' and b.OBJECT ='STCRMTB040P'
/



________ Rollback 

SELECT s.username, s.SID, s.serial#, s.logon_time, t.xidusn, t.ubafil,
t.ubablk, t.used_ublk, t.start_date, t.status
FROM v$session s, v$transaction t
WHERE s.saddr = t.ses_addr;


Undef sid
Select addr, start_time, USED_UBLK, USED_UREC, LOG_IO, PHY_IO, CR_GET, CR_CHANGE
From v$transaction t, v$session s
Where t.addr = s.taddr and sid=&&sid;
 

-- sommario dei segmenti di rollback per sessione
Col status for a6
Col name for a12
Col extents for 9999999
Col status for a6
Col username for a12
Select V$T.START_TIME, /*V$N.USN,*/ V$N.NAME, V$R.EXTENTS, V$R.XACTS, V$R.STATUS,
       V$S.SID, V$S.SERIAL#, V$S.USERNAME, V$S.osuser, v$p.spid
       --to_char(V$T.UBAFIL) ubafil, --to_char(V$T.UBASQN) ubasnq, --to_char(V$T.UBAREC) ubarec, --to_char(V$T.UBABLk) ubablk
  From V$ROLLNAME      V$N,
       V$ROLLSTAT      V$R,
       V$TRANSACTION   V$T,
       V$SESSION       V$S,
       V$process v$p
 Where V$S.TADDR = V$T.ADDR
   And v$p.addr=v$s.paddr
   And V$T.XIDUSN = V$R.USN
   And V$R.USN = V$N.USN
Order by 1;



____ Extract ___

set long 2000
set pagesize 22222
SELECT DBMS_METADATA.GET_DDL(  'INDEX', 'STCRMTB151N_IDX01',  'STCR_APPPRD') FROM DUAL;
SELECT DBMS_METADATA.GET_DDL(  'TABLE', 'STRCGDTB021N',  'RCG_APPPRD') FROM DUAL;



______ OPTIMIZER_INDEX_COST_ADJ and OPTIMIZER_INDEX_CACHING

col c1 heading 'Average Waits for|Full Scan Read I/O' format 9999.999
col c2 heading 'Average Waits for|Index Read I/O' format 9999.999
col c3 heading 'Percent of| I/O Waits|for scattered|Full Scans' format 999.99
col c4 heading 'Percent of| I/O Waits|for sequential|Index Scans' format 9999.99
col c5 heading 'Starting|Value|for|optimizer|index|cost|adj' format 999
 
select
   sum(a.time_waited_micro)/sum(a.total_waits)/1000000 c1,
   sum(b.time_waited_micro)/sum(b.total_waits)/1000000 c2,
   (
      sum(a.total_waits) /
      sum(a.total_waits + b.total_waits)
   ) * 100 c3,
   (
      sum(b.total_waits) /
      sum(a.total_waits + b.total_waits)
   ) * 100 c4,
  (
      sum(b.time_waited_micro) /
      sum(b.total_waits)) /
      (sum(a.time_waited_micro)/sum(a.total_waits)
   ) * 100 c5
from
   dba_hist_system_event a,
   dba_hist_system_event b
where
   a.snap_id = b.snap_id
and
   a.event_name = 'db file scattered read'
and
   b.event_name = 'db file sequential read';                     
   
   
   

++++++++++++++++++++++++++++++++++++++
opatch
++++++++++++++++++++++++++++++++++++++       


tar -cvf /tmp/opatch_storage /sw/oracle/11.1.0/db/.patch_storage/

opatch util cleanup -ps 6121183_Ju _21_2007_04_19_42

1012  cd /sw/oracle/11.1.0/db/.patch_storage/
 1013  ls -d *2006*
 1014  ls -ld *2009*
 1015  /sw/oracle/11.1.0/db/OPatch/opatch cleanup -ps 7338648_Nov_23_2009_01_25_22

cd /sw/oracle/10.2.0/db
ls -d *_2006_* | while read aa ; do $ORACLE_HOME/OPatch/opatch cleanup -silent -ps $aa; done
ls -d *_2010_* | while read aa ; do $ORACLE_HOME/OPatch/opatch cleanup -silent -ps $aa; done
ls -d *_2008_* | while read aa ; do $ORACLE_HOME/OPatch/opatch cleanup -silent -ps $aa; done

opatch prereq CheckConflictAgainstOHWithDetail -phBaseDir ./11724936
opatch lsinventory -bugs_fixed

$ORACLE_HOME/OPatch/opatch lsinv -bugs_fixed | grep 'DATABASE PSU'



++++++++++++++++++++++++++++++++++++++
object
++++++++++++++++++++++++++++++++++++++


select count(*),object_type
from dba_objects
where owner='RCG_APPPRD'
group by object_type;


++++++++++++++++++++++++++++++++++++++
MALVEZZI - disable memory - component - sga
++++++++++++++++++++++++++++++++++++++


select component,avg(FINAL_SIZE),MIN(FINAL_SIZE),MAX(FINAL_SIZE)
  from v$sga_resize_ops
group by component
order by 2
/


set lines 100
col end_time format a16 head "Time Stamp"
col init format 999,999,999 head "Initial (MB)"
col target format 999,999,999 head "Target (MB)"
col final format 999,999,999 head "Final (MB)"
col component format a25 head "Component"
col status head "Status"

select inst_id,to_char(end_time,'dd-Mon hh24:mi') end_time, component,
(initial_size/1024/1024) init, (target_size/1024/1024) target,
(final_size/1024/1024) final, status
from gv$memory_resize_ops order by end_time;



COMPONENT                 AVG(FINAL_SIZE) MIN(FINAL_SIZE) MAX(FINAL_SIZE)
------------------------- --------------- --------------- ---------------
RECYCLE buffer cache                    0               0               0
DEFAULT 8K buffer cache                 0               0               0
DEFAULT 2K buffer cache                 0               0               0
DEFAULT 16K buffer cache                0               0               0
ASM Buffer Cache                        0               0               0
KEEP buffer cache                       0               0               0
DEFAULT 4K buffer cache                 0               0               0
large pool                       67108864        67108864        67108864
streams pool                   89478485.3        67108864       134217728
java pool                       134217728       134217728       134217728
DEFAULT 32K buffer cache        536870912       536870912       536870912
DEFAULT buffer cache           1024935377       872415232      1207959552
shared pool                    1572264814      1409286144      1677721600


select component,INITIAL_SIZE,FINAL_SIZE),MAX(FINAL_SIZE)
  from v$memory_resize_ops
group by component
/

++++++++++++++++++++++++++++++++++++++
INTO SGA
++++++++++++++++++++++++++++++++++++++
col MIN_SIZE for 999999999999999
col MAX_SIZE for 99999999999999
col CURRENT_SIZE for 9999999999999999

select component,min_size,max_size,current_size from v$sga_dynamic_components where MIN_SIZE != 0;






select to_char(end_time,'dd-Mon hh24:mi') end_time, component,
(initial_size/1024/1024) init, (target_size/1024/1024) target,
(final_size/1024/1024) final, status
from v$memory_resize_ops order by end_time;


set line 2222
col component for a20
col parameter for a20
ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MM-YYYY HH24:MI';
select * from v$memory_resize_ops order by START_TIME;


select component,avg(FINAL_SIZE),MIN(FINAL_SIZE),MAX(FINAL_SIZE)
  from v$sga_resize_ops
group by component
order by 2
/
set line 2222
col component for a20
col parameter for a20
ALTER SESSION SET NLS_DATE_FORMAT = 'HH24:MI';
select * from v$sga_resize_ops order by START_TIME;




###################
### BUFFER CACHE TABLE 
##################

set pages 999
set lines 80
spool blocks.lst

 

ttitle 'Contents of Data Buffers'

 

drop table t1;


create table t1 as
select
   o.object_name    object_name,
   o.object_type    object_type,
   count(1)         num_blocks
from
   dba_objects  o,
   v$bh         bh
where
   o.object_id  = bh.objd
and
   o.owner not in ('SYS','SYSTEM')
group by
   o.object_name,
   o.object_type
order by
   count(1) desc
;

column c1 heading "Object|Name"                 format a30
column c2 heading "Object|Type"                 format a12
column c3 heading "Number of|Blocks"            format 999,999,999,999
column c4 heading "Percentage|of object|data blocks|in Buffer" format 999

 

select
   object_name       c1,
   object_type       c2,
   num_blocks        c3,
   (num_blocks/decode(sum(blocks), 0, .001, sum(blocks)))*100 c4
from
   t1,
   dba_segments s
where
   s.segment_name = t1.object_name
and
   num_blocks > 10
group by
   object_name,
   object_type,
   num_blocks
order by
   num_blocks desc
;



++++++++++++++++++++++++++++++++++++++
Buffer pool type
++++++++++++++++++++++++++++++++++++++


select ID,name,BLOCK_SIZE,DB_BLOCK_GETS,CONSISTENT_GETS,PHYSICAL_READS from v$buffer_pool_statistics


++++++++++++++++++++++++++++++++++++++
buffer cache  object in memory    Buffer pool type 
++++++++++++++++++++++++++++++++++++++

Script to Identify Objects and Amount of Blocks in the Buffer Pools - Default, Keep, Recycle, nK Cache [ID 373472.1]

select decode(pd.bp_id,1,'KEEP',2,'RECYCLE',3,'DEFAULT',
         4,'2K SUBCACHE',5,'4K SUBCACHE',6,'8K SUBCACHE',
         7,'16K SUBCACHE',8,'32KSUBCACHE','UNKNOWN') subcache,
         bh.object_name,bh.blocks
from x$kcbwds ds,x$kcbwbpd pd,(select /*+ use_hash(x) */ set_ds,
         o.name object_name,count(*) BLOCKS
         from obj$ o, x$bh x where o.dataobj# = x.obj
         and x.state !=0 and o.owner# !=0
         group by set_ds,o.name) bh 
where ds.set_id >= pd.bp_lo_sid
and ds.set_id <= pd.bp_hi_sid
and pd.bp_size != 0
and ds.addr=bh.set_ds
order by 3;


++++++++++++++++++++++++++++++++++++++
 memory type usage
++++++++++++++++++++++++++++++++++++++
select subcache,sum(blocks) from (
select decode(pd.bp_id,1,'KEEP',2,'RECYCLE',3,'DEFAULT',
         4,'2K SUBCACHE',5,'4K SUBCACHE',6,'8K SUBCACHE',
         7,'16K SUBCACHE',8,'32KSUBCACHE','UNKNOWN') subcache,
         bh.object_name block_name,bh.blocks blocks
from x$kcbwds ds,x$kcbwbpd pd,(select /*+ use_hash(x) */ set_ds,
         o.name object_name,count(*) BLOCKS
         from obj$ o, x$bh x where o.dataobj# = x.obj
         and x.state !=0 and o.owner# !=0
         group by set_ds,o.name) bh 
where ds.set_id >= pd.bp_lo_sid
and ds.set_id <= pd.bp_hi_sid
and pd.bp_size != 0
and ds.addr=bh.set_ds
order by 3)
group by subcache
order by subcache;

++++++++++++++++++++++++++++++++++++++
buffer cache + segment_name, sum bloks
++++++++++++++++++++++++++++++++++++++

select subcache,block_name,sum(blocks) from 
(
select decode(pd.bp_id,1,'KEEP',2,'RECYCLE',3,'DEFAULT',
         4,'2K SUBCACHE',5,'4K SUBCACHE',6,'8K SUBCACHE',
         7,'16K SUBCACHE',8,'32KSUBCACHE','UNKNOWN') subcache,
         bh.object_name block_name,bh.blocks blocks
from x$kcbwds ds,x$kcbwbpd pd,(select /*+ use_hash(x) */ set_ds,
         o.name object_name,count(*) BLOCKS
         from obj$ o, x$bh x where o.dataobj# = x.obj
         and x.state !=0 and o.owner# !=0
         group by set_ds,o.name) bh 
where ds.set_id >= pd.bp_lo_sid
and ds.set_id <= pd.bp_hi_sid
and pd.bp_size != 0
and ds.addr=bh.set_ds
order by 3
)
group by subcache,block_name
order by sum(blocks);

++++++++++++++++++++++++++++++++++++++
buffer cache + segment_name, sum bloks  topten
++++++++++++++++++++++++++++++++++++++
select * from (
select subcache,block_name,sum(blocks) from
(
select decode(pd.bp_id,1,'KEEP',2,'RECYCLE',3,'DEFAULT',
         4,'2K SUBCACHE',5,'4K SUBCACHE',6,'8K SUBCACHE',
         7,'16K SUBCACHE',8,'32KSUBCACHE','UNKNOWN') subcache,
         bh.object_name block_name,bh.blocks blocks
from x$kcbwds ds,x$kcbwbpd pd,(select /*+ use_hash(x) */ set_ds,
         o.name object_name,count(*) BLOCKS
         from obj$ o, x$bh x where o.dataobj# = x.obj
         and x.state !=0 and o.owner# !=0
         group by set_ds,o.name) bh
where ds.set_id >= pd.bp_lo_sid
and ds.set_id <= pd.bp_hi_sid
and pd.bp_size != 0
and ds.addr=bh.set_ds
order by 3
)
group by subcache,block_name
order by sum(blocks) desc
)
where rownum < 10
/





select ID,name,BLOCK_SIZE,DB_BLOCK_GETS,CONSISTENT_GETS,PHYSICAL_READS from v$buffer_pool_statistics



############# Buffer cache table percen cache 



######### buffer cache 20 tab cached  in mem


column c1 heading "Object|Name"                 format a30
column c2 heading "Object|Type"                 format a12
column c3 heading "MB"            format 999,999,999,999
column c4 heading "Percentage|of object|data blocks|in Buffer" format 999

select * from 
(
select
   object_name       c1,
   object_type       c2,
   num_blocks*8192        c3,
   (num_blocks/decode(sum(blocks), 0, .001, sum(blocks)))*100 c4,
   t1.inst_id
from
   (select
   o.object_name    object_name,
   o.object_type    object_type,
   count(1)         num_blocks,
   bh.inst_id       inst_id
from
   dba_objects  o,
   gv$bh         bh
where
   o.object_id  = bh.objd
and
   o.owner not in ('SYS','SYSTEM')
group by
   o.object_name,
   o.object_type,
   bh.inst_id
order by
   count(1) desc
) t1,
   dba_segments s
where
   s.segment_name = t1.object_name
   --and s.segment_name like 'SLWTB064N'
and
   num_blocks > 10
group by
   t1.inst_id,
   object_name,
   object_type,
   num_blocks
order by
   num_blocks desc
)
where rownum < 20;


===========================================================================
--->
---> PRODUZIONE
--->

*.db_32k_cache_size=536870912
*.db_cache_size=1207959552
*.shared_pool_size=1677721600
*._memory_broker_shrink_heaps=0
*._library_cache_advice=false
*._enable_shared_pool_durations=FALSE
*.recyclebin=off




++++++++++++++++++++++++++++++++++++++
Buffer cache note, keep pool  http://download.oracle.com/docs/cd/B19306_01/server.102/b14211/memory.htm#i30311
++++++++++++++++++++++++++++++++++++++

7.2.6 Buffer Pool Hit Ratios
SELECT NAME, PHYSICAL_READS, DB_BLOCK_GETS, CONSISTENT_GETS,
      1 - (PHYSICAL_READS / (DB_BLOCK_GETS + CONSISTENT_GETS)) "Hit Ratio"
  FROM V$BUFFER_POOL_STATISTICS;



7.2.7 Determining Which Segments Have Many Buffers in the Pool

SELECT o.OBJECT_NAME, COUNT(*) NUMBER_OF_BLOCKS
     FROM DBA_OBJECTS o, V$BH bh
    WHERE o.DATA_OBJECT_ID = bh.OBJD
      AND o.OWNER         != 'SYS'
    GROUP BY o.OBJECT_NAME
    ORDER BY COUNT(*);

OBJECT_NAME                              NUMBER_OF_BLOCKS
---------------------------------------- ----------------
OA_PREF_UNIQ_KEY                                        1
SYS_C002651                                             1
..
DS_PERSON                                              78
OM_EXT_HEADER                                         701
OM_SHELL                                            1,765
OM_HEADER                                           5,826
OM_INSTANCE                                        12,644


.2.6 Buffer Pool Hit Ratios

SELECT NAME, PHYSICAL_READS, DB_BLOCK_GETS, CONSISTENT_GETS,
      1 - (PHYSICAL_READS / (DB_BLOCK_GETS + CONSISTENT_GETS)) "Hit Ratio"
  FROM V$BUFFER_POOL_STATISTICS;


++++++++++++++++++++++++++++++++++++++
-- BIND variable and sqlplus
++++++++++++++++++++++++++++++++++++++


var B1 varchar2(3)
var B2 number
var B3 char(1)
begin
:B1:='011';
:B2:=52124;
:B3:=1;
end;
/

SELECT I.ID_ISTR, OP.ID_OPE, OP.COD_TIT, OP.QTA_OPE,
 OP.SEG_TIT, OP.SEG_LIQ, OP.CTV_OPE, OP.CTV_TOT, 
 OP.CTV_OPE_NEG, OP.CTV_TOT_NEG, OP.COD_DIV_NEG, 
 OP.CAM_REG, OP.CAM_DA_VM, I.COD_DIV_REG, 
 I.TIPO_IMP, I.COD_CONTO_DEPOSIT_CAB_LIQ,
  I.COD_CONTO_DEPOSIT_CAB_TIT, 
  I.ID_COORDINATA_LIQ, 
  I.ID_COORDINATA_TIT, 
  I.COD_DEPOSIT_CAB,
   OP.COD_MERC_LOC,
    I.DTA_VAL, 
    I.IND_FREE_AGAINST, I.TIPO_INT_EXT, I.TIPO_TIT_LIQ, NVL(L.VALORE_RAGG_FATTORE,1) AS FATTORE
     FROM VW_OPERAZIONE_BATCH OP, TB_LINK_OPE_ISTR L, TB_ISTRUZIONE I 
     WHERE OP.ID_OPE=L.ID_OPE AND OP.COD_SOC = L.COD_SOC 
     AND L.ID_ISTR=I.ID_ISTR AND L.COD_SOC=I.COD_SOC 
     AND L.IND_LINK_ATT=:B3 AND I.ID_ISTR =:B2 
     AND OP.COD_SOC =:B1;
     
     
     
++++++++++++++++++++++++++++++++++++++
DBA_HIST_SQL_PLAN
++++++++++++++++++++++++++++++++++++++
 

--vecchio piano

select TIMESTAMP,SQL_ID,PLAN_HASH_VALUE from DBA_HIST_SQL_PLAN where SQL_ID='73nqawpq5ragr' order by 1;
select TIMESTAMP,SQL_ID,PLAN_HASH_VALUE,count(*) from DBA_HIST_SQL_PLAN where SQL_ID='99kp5ma59jzfr' group by TIMESTAMP,SQL_ID,PLAN_HASH_VALUE order by 1;
select to_char(TIMESTAMP,'DD-MM-YYYY HH24:MI'),SQL_ID,PLAN_HASH_VALUE from DBA_HIST_SQL_PLAN where SQL_ID='99kp5ma59jzfr' order by 1; 
select to_char(TIMESTAMP,'DD-MM-YYYY HH24:MI'),SQL_IDlesp,PLAN_HASH_VALUE,count(*) 
from DBA_HIST_SQL_PLAN where SQL_ID='99kp5ma59jzfr' 
group by to_char(TIMESTAMP,'DD-MM-YYYY HH24:MI'),SQL_ID,PLAN_HASH_VALUE order by 1;

-- rac

set lines 155
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a30
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id, ss.instance_number node, begin_interval_time, sql_id, plan_hash_value,
nvl(executions_delta,0) execs,
(elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime,
(buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = nvl('&sql_id','80bfsyad6kcqn')
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3
/

 SNAP_ID   NODE BEGIN_INTERVAL_TIME            SQL_ID        PLAN_HASH_VALUE        EXECS    AVG_ETIME        AVG_LIO
---------- ------ ------------------------------ ------------- --------------- ------------ ------------ --------------
     73473      2 31-OCT-11 01.00.16.414 AM      0h8dbu16rzuhq      3612138191            1       82.802      845,025.0
     73545      1 03-NOV-11 01.00.17.532 AM      0h8dbu16rzuhq                            1      110.705      870,525.0
     73555      1 03-NOV-11 11.00.05.258 AM      0h8dbu16rzuhq                            2      168.203    1,926,951.0
     73555      5 03-NOV-11 11.00.05.491 AM      0h8dbu16rzuhq                            8      170.235    2,882,284.1
     73556      5 03-NOV-11 12.00.20.120 PM      0h8dbu16rzuhq                           12      146.950    2,595,248.4
     73569      5 04-NOV-11 01.00.29.305 AM      0h8dbu16rzuhq                            1      109.501      882,566.0
     73644      1 07-NOV-11 04.00.03.118 AM      0h8dbu16rzuhq      3220955237            1    1,435.655   14,883,283.0
     73654      1 07-NOV-11 02.00.34.700 PM      0h8dbu16rzuhq                            3      605.415   10,521,315.3

 


select to_char(TIMESTAMP,'DD-MM-YYYY HH24:MI'),SQL_ID,PLAN_HASH_VALUE from DBA_HIST_SQL_PLAN where SQL_ID='8d4762rbaq2tu' order by 1;

--piano attuale, da fare sul nodo in cui è attiva la sessione

select TIMESTAMP,SQL_ID,PLAN_HASH_VALUE,count(*) from gv$SQL_PLAN where SQL_ID='c9t32awcjygh4' group by TIMESTAMP,SQL_ID,PLAN_HASH_VALUE order by 1;
select TIMESTAMP,SQL_ID,PLAN_HASH_VALUE,count(*) from DBA_HIST_SQL_PLAN where SQL_ID='c9t32awcjygh4' group by TIMESTAMP,SQL_ID,PLAN_HASH_VALUE order by 1;

 

-- per vedere piano 

select SQL_ID,PLAN_HASH_VALUE from v$SQL_PLAN where SQL_ID='dmwfxrkvqat7j' order by 1;
select ID,OPERATION,OPTIONS,OBJECT_NAME from DBA_HIST_SQL_PLAN where SQL_ID='dmwfxrkvqat7j';
and PLAN_HASH_VALUE=3566424539  ;



++++++++++++++++++++++++++++++++++++++
parallel 11
++++++++++++++++++++++++++++++++++++++
srvctl add service -d RCGPRD -s PX1 -r RCGPRD1
srvctl add service -d RCGPRD -s PX2 -r RCGPRD2
srvctl start service -d rCGPRD -s pX1
srvctl start service -d rCGPRD -s pX2
SQL> alter system set parallel_instance_group='PX1' sid='RCGPRD1' ;
show parameter parallel_instance_group
SQL> alter system set parallel_instance_group='PX2' sid='RCGPRD2' ;
show parameter parallel_instance_group

srvctl add service -d RCGCOLB -s PX1 -r RCGCOLB3
srvctl add service -d RCGCOLB -s PX2 -r RCGCOLB4
srvctl start service -d RCGCOLB -s pX1
srvctl start service -d RCGCOLB -s pX2
 alter system set parallel_instance_group='PX1' sid='RCGCOLB3' ;
 alter system set parallel_instance_group='PX2' sid='RCGCOLB4' ;



++++++++++++++++++++++++++++++++++++++
PARAMETER
++++++++++++++++++++++++++++++++++++++


select NAME,VALUE from v$parameter where name like '%pga%';


select NAME,VALUE from v$spparameter where name like '%pga%';






++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++

RROR at line 1:
ORA-04068: existing state of packages has been discarded
ORA-04065: not executed, altered or dropped stored procedure
"RCG_APPPRD.STRCGWPRC_LOG"
ORA-06508: PL/SQL: could not find program unit being called:
"RCG_APPPRD.STRCGWPRC_LOG"
ORA-06512: at "RCG_APPPRD.STRCGWFNC_GET_PARTITION_NAME", line 29
ORA-01403: no data found
ORA-06512: at line 3

set pagesize 10000
column d_name format a20
column p_name format a20
select do.obj# d_obj,do.name d_name, do.type# d_type,
po.obj# p_obj,po.name p_name,
to_char(p_timestamp,'DD-MON-YYYY HH24:MI:SS') "P_Timestamp",
to_char(po.stime ,'DD-MON-YYYY HH24:MI:SS') "STIME",
decode(sign(po.stime-p_timestamp),0,'SAME','*DIFFER*') X
from sys.obj$ do, sys.dependency$ d, sys.obj$ po
where P_OBJ#=po.obj#(+)
and D_OBJ#=do.obj#
and do.status=1 /*dependent is valid*/
and po.status=1 /*parent is valid*/
and po.stime!=p_timestamp /*parent timestamp not match*/
order by 2,1;




++++++++++++++++++++++++++++++++++++++
TEMP USAGE
++++++++++++++++++++++++++++++++++++++

col sid for 99999
col last_call for a8
col username for a10
col osuser for a16
col machine for a16
col event for a32
select a.SID,        
       to_char(sysdate - last_call_et / 86400,'DDHH24MISS')  as LAST_CALL,
       a.USERNAME, STATUS, OSUSER, MACHINE, 
       w.EVENT,
       w.SECONDS_IN_WAIT SEC,
       t.TABLESPACE,
       t.BLOCKS as TEMP_BLOCKS
from gv$session a,
     gv$process p,
     gv$session_wait w,
     v$tempseg_usage t
where nvl(t.BLOCKS,0) >0
  and p.ADDR = a.pADDR
  and p.inst_id = a.inst_id
  and a.saddr = t.session_addr (+)
  and w.sid (+) = a.sid
  and w.inst_id (+) = a.inst_id
order by temp_blocks desc;



++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++

select INSTANCE_NUMBER, NAME , BLOCK_SIZE, max(BUFFER_BUSY_WAIT) 
from DBA_HIST_BUFFER_POOL_STAT 
where snap_id between 30363 and 30378 
group by INSTANCE_NUMBER, NAME , BLOCK_SIZE 
order by 1,2,3 

/ 

++++++++++++++++++++++++++++++++++++++
SHARED POOL
++++++++++++++++++++++++++++++++++++++

1059022.1

Oracle keeps SQL statements, packages, object information and many other items in an area in the SGA known as the shared pool. This sharable area of memory is managed as a sophisticated cache and heap manager rolled into one. It has 3 fundamental problems to overcome: 

Pinning objects in the shared pool can provide a tremendous increase in database performance, if it is done correctly. 
Since pinned objects reside in the SQL and PL/PLSQL memory areas, they do not need to be loaded and parsed from the database, which saves considerable time. 


What objects to be pinned into the shared pool?

SELECT substr(owner,1,10)||'.'||substr(name,1,35) "Object Name",
' Type: '||substr(type,1,12)||
' size: '||sharable_mem ||
' execs: '||executions||
' loads: '||loads||
' Kept: '||kept
FROM v$db_object_cache
WHERE type in ('TRIGGER','PROCEDURE','PACKAGE BODY','PACKAGE')
AND executions > 0
ORDER BY executions desc,
loads desc,
sharable_mem desc;

Choose the objects with a high number of executions (EXECS) or very large (SPACE(K)), frequently used objects. 
If the decision is between two objects that have been executed the same number of times, then preference should be given to the larger object. From experience, very good results have been achieved with having pinned only about 10 packages.

++++++++++++++++++++++++++++++++++++++
SHARED POOL - CURSOR SHARING
++++++++++++++++++++++++++++++++++++++
cursor_sharing=similar: "Causes statements that may differ in some literals, but are otherwise identical, to share a cursor, unless the literals affect either the meaning of the statement or the degree to which the plan is optimized."




++++++++++++++++++++++++++++++++++++++
Tuning the Shared Pool and Tuning Library Cache Latch Contention [ID 62143.1]
++++++++++++++++++++++++++++++++++++++


    Latch contention for the library cache latch/es
    Latch contention for the shared pool latch
    High CPU parse times
    High numbers of reloads in V$LIBRARYCACHE
    High numbers of versions of cursors
    Lots of parse calls
    Frequent ORA-04031 errors


--------- Finding literal SQL
          SELECT substr(sql_text,1,40) "SQL", 
                 count(*) , 
                 sum(executions) "TotExecs"
            FROM v$sqlarea
           WHERE executions < 5
           GROUP BY substr(sql_text,1,40)
          HAVING count(*) > 30
           ORDER BY 2
          ;


This helps find commonly used literal SQL - See "Eliminating Literal SQL" above.

---------- Finding the Library Cache hit ratio
        
		SELECT SUM(PINS) "EXECUTIONS",
        SUM(RELOADS) "CACHE MISSES WHILE EXECUTING",(100*SUM(RELOADS))/SUM(PINS)
        FROM V$LIBRARYCACHE;

If the ratio of misses to executions is more than 1%, then try to reducethe library cache misses

Checking for high version counts:

        SELECT address, hash_value,
                version_count ,
                users_opening ,
                users_executing,
                substr(sql_text,1,40) "SQL"
          FROM v$sqlarea
         WHERE version_count > 10
        ;

		Versions" of a statement occur where the SQL is character for character
identical but the underlying objects or binds etc.. are different as described
in "Sharable SQL" above.

-----Finding statement/s which use lots of shared pool memory:

set pagesize 300
            SELECT substr(sql_text,1,40) "Stmt", count(*),
                    trunc(sum(sharable_mem/(1024)))    "Mem KB",
                    sum(users_opening)   "Open",
                    sum(executions)      "Exec"
              FROM v$sql
             GROUP BY substr(sql_text,1,40)
             order by 3;

---- Shared pool used and available
set pagesize 300
            SELECT sum( trunc(sum(sharable_mem/(1024))))    "sum Mem KB"
                                      FROM v$sql
                   GROUP BY substr(sql_text,1,40)
                       ;

select TARGET_SIZE,FINAL_SIZE,to_char(START_TIME,'DD-MM-YYYY HH24:MI') from v$memory_resize_ops
																					where parameter = 'shared_pool_size'
																					order by START_TIME;
 
 
 
 ------------------------------------------------------------------------------------------           
									            select TARGET_SIZE,FINAL_SIZE,START_TIME from v$memory_resize_ops
																					where parameter = 'shared_pool_size'
																					order by START_TIME;
									
									
									TARGET_SIZE FINAL_SIZE START_TIM
									----------- ---------- ---------
									 1023410176 1023410176 19-OCT-11
									 1073741824 1073741824 19-OCT-11
									 1124073472 1124073472 19-OCT-11
									 1174405120 1174405120 19-OCT-11
									 1124073472 1124073472 19-OCT-11
									 1174405120 1174405120 19-OCT-11
									  922746880  922746880 19-OCT-11
									  889192448  889192448 19-OCT-11
									
									
									
									            SELECT substr(sql_text,1,40) "Stmt", count(*),
									                    sum(sharable_mem)    "Mem",
									                    sum(users_opening)   "Open",
									                    sum(executions)      "Exec"
									              FROM v$sql
									             GROUP BY substr(sql_text,1,40)
									            HAVING sum(sharable_mem) > 88919244
									            ;
	-------------------------------------------------------------------
    where MEMSIZE is about 10% of the shared pool size in bytes. This should show if there are similar literal statements, or multiple versions of a statements which account for a large portion of the memory in the shared pool.
	
	Allocations causing shared pool memory to be 'aged' out

        SELECT * 
          FROM x$ksmlru
        WHERE ksmlrnum>0
        ;


Note: This select returns no more than 10 rows and then erases the
contents of the X$KSMLRU table so be sure to SPOOL the output. The X$KSMLRU
table shows which memory allocations have caused the MOST memory chunks
to be thrown out of the shared pool since it was last queried. This is
sometimes useful to help identify sessions or statements which are continually
causing space to be requested. If a system is well behaved and uses well
shared SQL, but occasionally slows down this select can help identify the
cause. Refer to Note:43600.1 for more information on X$KSMLRU.



++++++++++++++++++++++++++++++++++++++
DATABASE PERFORMANCE 
++++++++++++++++++++++++++++++++++++++

Master Note: Database Performance Overview [ID 402983.1]



++++++++++++++++++++++++++++++++++++++
--- Come capire se viene usato un indice in un tempo ----
++++++++++++++++++++++++++++++++++++++


COLUMN   program ON FORMAT   a30
COLUMN   machine ON FORMAT   a15
col START for a30
col end for a31
select SESS.SNAP_ID,SESS.SQL_ID,SESS.INSTANCE_NUMBER,SESS.MACHINE,SESS.PROGRAM,
to_char(SNAP.BEGIN_INTERVAL_TIME,'DD-MM-YYYY HH24:MI') "START" ,to_char(SNAP.END_INTERVAL_TIME,'DD-MM-YYYY HH24:MI') "END"
from DBA_HIST_ACTIVE_SESS_HISTORY SESS, DBA_HIST_SNAPSHOT SNAP
where 
SESS.SNAP_ID=SNAP.SNAP_ID
and   to_char(SNAP.BEGIN_INTERVAL_TIME,'DD-MM-YYYY HH24:MI') >= '11-11-2011 08:00' 
and   to_char(SNAP.END_INTERVAL_TIME,'DD-MM-YYYY HH24:MI')   <= '11-11-2011 18:00'
and SESS.SQL_ID in (
select  distinct(SQL_ID)
from DBA_HIST_SQL_PLAN
where  OBJECT_OWNER = 'STCR_APPPRD'
and OBJECT_NAME like 'STCRMTB094P_IDX01'
)
;


++++++++++++++++++++++++++++++++++++++
ROLE privilegs
++++++++++++++++++++++++++++++++++++++

rem Filename:   badsysprivs.sql
rem Purpose:    Database users with deadly system privilages assigned to 
rem             them.
rem Date:       04-Nov-2001
rem Author:     Frank Naude, Oracle FAQ



select grantee, privilege, admin_option
from   sys.dba_sys_privs 
where  (privilege like '% ANY %'
  or   privilege in ('BECOME USER', 'UNLIMITED TABLESPACE')
  or   admin_option = 'YES')
 and   grantee not in ('SYS', 'SYSTEM', 'OUTLN', 'AQ_ADMINISTRATOR_ROLE',
                       'DBA', 'EXP_FULL_DATABASE', 'IMP_FULL_DATABASE',
                       'OEM_MONITOR', 'CTXSYS', 'DBSNMP', 'IFSSYS',
                       'IFSSYS$CM', 'MDSYS', 'ORDPLUGINS', 'ORDSYS',
                       'TIMESERIES_DBA')
/



++++++++++++++++++++++++++++++++++++++
two face

Thu Jan 12 00:58:48 CET 2012
Errors in file /sw/oracle/admin/FUADPRD/bdump/fuadprd2_reco_8575.trc:
ORA-28500: connection from ORACLE to a non-Oracle system returned this message:
ORA-02063: preceding line from SYB

++++++++++++++++++++++++++++++++++++++




Manually Resolving In-Doubt Transactions: Different Scenarios [ID 126069.1]
..

In reality, you should only need to resolve an in-doubt transaction in the
following cases:
- the in-doubt transaction has locks on critical data or rollback segments
- the cause of the machine, network or software failure cannot be repaired
quickly

The RECO background process (Distributed Recovery process) of an 
Oracle instance automatically resolves failures involving distributed
transactions, when the machine, network, or software problem is resolved. 
Until RECO can resolve the transaction, the data is locked for both reads 
and writes. Oracle blocks reads because it cannot determine which version 
of the data to display for a query.

…
How To Resolve Stranded DBA_2PC_PENDING Entries [ID 401302.1]


select local_tran_id, state from dba_2pc_pending;

set transaction use rollback segment SYSTEM;

delete from sys.pending_trans$
where local_tran_id = '1.92.66874';

delete from sys.pending_sessions$ where local_tran_id = '1.92.66874';

delete from sys.pending_sub_sessions$ where local_tran_id = '1.92.66874';

commit;






++++++++++++++++++++++++++++++++++++++
Block BBED
++++++++++++++++++++++++++++++++++++++

X:\Offices1\ISS-AS\_SistemiBo\Ste\__Oracle\disa*




++++++++++++++++++++++++++++++++++++++
BLOCK TACKING
++++++++++++++++++++++++++++++++++++++


SELECT (count(distinct b.fno||' '||bno) * 32)/1024 MB
  2  FROM x$krcbit b,
  3  (SELECT MIN(ver) min_ver, fno        FROM
  4  (SELECT curr_vercnt ver,
  5  curr_highscn high,
  6  curr_lowscn low,
  7  fno           FROM x$krcfde
  8  UNION ALL
  9  SELECT
 10  vercnt ver,
 11  high,
 12  low,
 13  fno
 14  FROM x$krcfbh )
 15  WHERE (SELECT MAX(bd.checkpoint_change#)
 16  FROM   v$backup_datafile bd
 17  WHERE  bd.incremental_level <= 1)
 18  between low and high
 19  GROUP BY fno      ) sub
 20  WHERE b.fno = sub.fno AND b.vercnt >= sub.min_ver ;

        MB
----------
 163.65625
 
 ALTER DATABASE ENABLE BLOCK CHANGE TRACKING USING FILE '/recovery_area/FTFIDCOL/tracking/FTFIDCOL.track.log';
 ALTER DATABASE DISABLE BLOCK CHANGE TRACKING;





++++++++++++++++++++++++++++++++++++++
KILL RAC
++++++++++++++++++++++++++++++++++++++

select 'ALTER SYSTEM DISCONNECT SESSION '''||sid||','||serial#||',@'||inst_id||''' IMMEDIATE;'
from gv$Session
where 1=1
and username like '%SOPHIS_VALUE_4%';




++++++++++++++++++++++++++++++++++++++
TEMP SORT USAGE
++++++++++++++++++++++++++++++++++++++

   set lines 190
   set pages 0
   set echo on verify off head on feed off timing off time on
   select to_char(sysdate,'yyyy/mm/dd HH24:MI:SS') from dual;
   set pages 999
col tablespace_name format a40
col "size MB" format 999,999,999
col "free MB" format 99,999,999
col "% Used" format 999

--Statement che usano la temp:
        SELECT USER,SQLADDR,SQLHASH,SQL_ID,TABLESPACE,CONTENTS,SEGTYPE,EXTENTS,BLOCKS, SEGBLK# FROM      v$tempseg_usage;
-- quali user usano la temp
        select s.username, u."USER", u.tablespace, u.contents, u.extents, u.blocks
        from   sys.v_$session s, sys.v_$sort_usage u
        where  s.saddr = u.session_addr
        /

SELECT A. tablespace_name tablespace,
  Round(((SUM (A. used_blocks * D.block_size ) / 1024 / 1024 ) * 100 )/ D.mb_total ) "% Used"
FROM  gv$sort_segment A,
  (
  SELECT  B .name,  C.block_size , SUM ( C.bytes ) / 1024 / 1024  mb_total
  FROM  v$tablespace B ,  v$tempfile C
  WHERE B.ts# =  C.ts#
  GROUP BY  B .name,  C.block_size
  )  D
WHERE A. tablespace_name =  D .name
GROUP by A. tablespace_name ,  D.mb_total ;
   exit
EOF


++++++++++++++++++++++++++++++++++++++
MTS shared pool
++++++++++++++++++++++++++++++++++++++




Shared Server (MTS) Diagnostics [ID 1005259.6]


++++++++++++++++++++++++++++++++++++++
Configurazione
++++++++++++++++++++++++++++++++++++++
backup spfile
lsnrctl service LISTENER_RRDBBO01FC
ALTER SYSTEM SET DISPATCHERS='(PROTOCOL=TCP)(DISPATCHERS=10)(INDEX=1)(SERVICE=WRCOLSRV1)' scope=both sid='*'; 
alter system set max_dispatchers = 100 scope=both sid='*'; 
ALTER SYSTEM REGISTER;
lsnrctl service LISTENER_RRDBBO01FC
alter system set shared_servers = 10 scope=both sid='*';
ALTER SYSTEM SET MAX_SHARED_SERVERS = 200 scope=both sid='*'; 



++++++++++++++++++++++++++++++++++++++
RESET PARAMTER
++++++++++++++++++++++++++++++++++++++

ALTER SYSTEM SET DISPATCHERS='' scope=both sid='*';

alter system set shared_servers = 0 scope=both sid='*';
alter system set max_dispatchers = 0 scope=both sid='*'; 
alter system set MAX_SHARED_SERVERS=0 scope=both sid='*'; 
++++++++++++++++++++++++++++++++++++++
TEST CLIENT
++++++++++++++++++++++++++++++++++++++

MTSTEST =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = rrdbbo01fcvip)(PORT = 1523))
    (ADDRESS = (PROTOCOL = TCP)(HOST = rrdbbo02fcvip)(PORT = 1523))
    (LOAD_BALANCE = yes)
    (CONNECT_DATA =
      (SERVER = SHARED)
      (SERVICE_NAME = WRCOLSRV1)
      (FAILOVER_MODE =
        (TYPE = SELECT)
        (METHOD = BASIC)
        (RETRIES = 180)
        (DELAY = 5)
      )
    )
  )







REM--++++++++++++++++++++++++++++++++++++++
REM --MTS : Conta quanti dispatcher
REM --++++++++++++++++++++++++++++++++++++++


--SELECT inst_id,CONF_INDX, NAME, NETWORK FROM gV$DISPATCHER; 


select inst_id,count(*) from  gV$DISPATCHER group by inst_id; 

  INST_ID   COUNT(*)
---------- ----------
         1         20
         2         20

REM--++++++++++++++++++++++++++++++++++++++
REM--Dispatchers: Monitoring Performance
REM--++++++++++++++++++++++++++++++++++++++

 SELECT INST_id,NAME "NAME", SUBSTR(NETWORK,1,23) "PROTOCOL", OWNED,
 STATUS "STATUS", (BUSY/(BUSY + IDLE)) * 100 "%TIME BUSY"
 FROM GV$DISPATCHER;

In general, Dispatchers will not be very busy because their tasks are relatively quick to complete. In the example below, Dispatchers are less than 1% busy. 
 The OWNED column of V$DISPATCHER view shows the number of clients currently connected to each Dispatche

REM--++++++++++++++++++++++++++++++++++++++
REM  --MTS Dispatcher: Performance
REM --++++++++++++++++++++++++++++++++++++++

 SELECT D.INST_id,D.NAME, Q.QUEUED, Q.WAIT, Q.TOTALQ,
 DECODE(Q.TOTALQ,0,0,(Q.WAIT/Q.TOTALQ)/100) "AVG WAIT"
 FROM GV$QUEUE Q, GV$DISPATCHER D
 WHERE D.PADDR = Q.PADDR
 AND Q.INST_id = d.INST_ID; 
 
 One perspective for interpreting Dispatcher performance is measuring the wait times in the various queues by querying the view V$QUEUE. 



  
REM--++++++++++++++++++++++++++++++++++++++
REM  --MTS SHARED SERVER: average time for instance
REM --++++++++++++++++++++++++++++++++++++++
 SELECT inst_id,DECODE(TOTALQ, 0, 'No Requests',
WAIT/TOTALQ || ' HUNDREDTHS OF SECONDS') "AVERAGE WAIT TIME PER REQUESTS"
FROM gV$QUEUE
WHERE TYPE = 'COMMON'; 


REM--++++++++++++++++++++++++++++++++++++++
REM  --MTS SHARED SERVER: How Many Shared server?
REM --++++++++++++++++++++++++++++++++++++++


SELECT inst_id,MAXIMUM_CONNECTIONS "MAX CONN", MAXIMUM_SESSIONS "MAX SESS",
   SERVERS_STARTED "STARTED", SERVERS_TERMINATED "TERMINATED",
   SERVERS_HIGHWATER "HIGHWATER"
   FROM gV$SHARED_SERVER_MONITOR; 




REM--++++++++++++++++++++++++++++++++++++++
REM  --MTS SHARED SERVER: Shared Server Performance
REM --++++++++++++++++++++++++++++++++++++++


SELECT inst_id,NAME "NAME", PADDR, REQUESTS,
 (BUSY/(BUSY + IDLE)) * 100 "%TIME BUSY", STATUS
 FROM gV$SHARED_SERVER 
 where requests != 0 ;

REM--++++++++++++++++++++++++++++++++++++++
REM  --MTS SHARED SERVER: How are using Shared?
REM --++++++++++++++++++++++++++++++++++++++

SELECT SERVER, SUBSTR(USERNAME,1,15) "USERNAME",
  SUBSTR(OSUSER,1,8) "OS USER", SUBSTR(MACHINE,1,7) "MACHINE",
  SUBSTR(PROGRAM,1,35) "PROGRAM"
  FROM gV$SESSION
  WHERE TYPE='USER' and server not like 'DEDICATED';






++++++++++++++++++++++++++++++++++++++
PGA
++++++++++++++++++++++++++++++++++++++

select component,avg(FINAL_SIZE),MIN(FINAL_SIZE),MAX(FINAL_SIZE)
  from v$pga_resize_ops
group by component
order by 2
/



SELECT round (PGA_TARGET_FOR_ESTIMATE/1024/1024) target_mb, 
       ESTD_PGA_CACHE_HIT_PERCENTAGE cache_hit_perc, 
       ESTD_OVERALLOC_COUNT 
FROM   v$pga_target_advice; 


select * from v$pga_target_advice order by pga_target_for_estimate;

select max(pga_used_mem), max(pga_alloc_mem), max(pga_max_mem) from v$process

MAX(PGA_USED_MEM) MAX(PGA_ALLOC_MEM) MAX(PGA_MAX_MEM)
----------------- ------------------ ----------------
         79093140          589476212        589476212



SELECT s.SID,pga_used_mem,pga_alloc_mem,pga_max_mem,PGA_FREEABLE_MEM
FROM V$PROCESS p, V$SESSION S
WHERE p.ADDR = s.PADDR 
and s.username like '%APPPRD';



direct path writes happen most often because of 
    sort operations
but can also happen for direct load 
	sqlldr direct=y
	insert /* +append */

For sorts operations (merge,hash, sort etc) that overflow their 
sort area sizes 
   bitmap_merge_area_size     
   create_bitmap_area_size   
   hash_area_size           
   sort_area_retained_size  
   sort_area_size          
or PGA max sizes 9i+
    workarea_size_policy=AUTO
    _pga_max_size      
    pga_aggregate_target
(also see _smm_max_size which seems to me the max memory size for the process)
will write to TEMP. These writes are coming from PGA and writing
directly to DISK bypassing the buffer cache and DBWR

Statspack data from a machine with sort write issues and one working well
TEMP write issues
                                                                   Avg
                                                     Total Wait   wait    Waits
Event                               Waits   Timeouts   Time (s)   (ms)     /txn
---------------------------- ------------ ---------- ---------- ------ --------
direct path write                  40,398          0      6,233    154     10.7
direct path read                   53,944          0        875     16     14.2

Working Correctly
                                                                   Avg
                                                     Total Wait   wait    Waits
Event                               Waits   Timeouts   Time (s)   (ms)     /txn
---------------------------- ------------ ---------- ---------- ------ --------
direct path read                  582,480          0      1,119      2    133.5
direct path write                 139,800          0        593      4     32.0


Checking for sort usage 

     column space format 999,999,999,999
     select   se.username
             ,se.sid
             ,su.extents
             ,su.blocks * to_number(rtrim(p.value)) as Space
             ,tablespace
             ,segtype
     from     v$sort_usage su
             ,v$parameter  p
             ,v$session    se
     where    p.name          = 'db_block_size'
     and      su.session_addr = se.saddr
     order by se.username, se.sid
     /
     
     select
          x$ktsso.inst_id inst_id,    -- INST_ID NUMBER
          username usern,             -- USER VARCHAR2(30)
          ktssoses sess_add,          -- SESSION_ADDR RAW(4)
          ktssosno sess# ,            -- SESSION_NUM NUMBER
          prev_sql_addr sql_addr,     -- SQLADDR RAW(4)
          prev_hash_value sql_hash,   -- SQLHASH NUMBER
          ktssotsn tabspc#,           -- TABLESPACE VARCHAR2(31)
          decode                      -- CONTENTS VARCHAR2(9)
            (ktssocnt, 0, 'PERMANENT', 1, 'TEMPORARY'),
          decode                      -- SEGTYPE VARCHAR2(9)
            (ktssosegt, 1, 'SORT', 2, 'HASH', 3, 'DATA', 4, 'INDEX', 5, 'LOB_DATA', 6, 'LOB_INDEX', 'UNDEFINED'),
          ktssofno file#,             -- SEGFILE# NUMBER
          ktssobno blk#,              -- SEGBLK# NUMBER
          ktssoexts extents,          -- EXTENTS NUMBER
          ktssoblks blocks,           -- BLOCKS NUMBER
          ktssorfno  rfile#           -- SEGRFNO# NUMBER
     from
             x$ktsso,
             v$session
     where
            ktssoses = v$session.saddr and 
            ktssosno = v$session.serial#
     /

Also it can be of interest to look at PGA sizes to show who might
or should be writing to TEMP

      column name format a30
      column Megs format 9,999.999
      select s.sid,  n.name, s.value/(1024*1024) Megs
      from v$sesstat s,
           v$statname n
      where n.statistic# =  s.statistic# and
           n.name like '%pga%'
      and sid=310
      order by value
      /


// PGA PERCE      
select
name,
to_char(decode( unit,'bytes', value/1024/1024, value ),'999,999,999.9') value,
decode( unit, 'bytes', 'mbytes', unit ) unit
from
v$pgastat
/      

++++++++++++++++++++++++++++++++++++++
anage_stacktrace_20120415-072502-932.log:java.sql.SQLException: ORA-01031: insufficient privileges

anage_stacktrace_20120415-072502-

++++++++++++++++++++++++++++++++++++++


SQL> alter system set events '1031 trace name errorstack level 3' ;

System altered.


ksedmp: internal or fatal error
ORA-01031: insufficient privileges
Current SQL statement for this session:
INSERT INTO T_MONITOR_TRAVASO (DTA_TRAVASO, COD_IP, ELABORARE, INCOMPLETI, SCARTATI, ELABORATI, COD_FLUSSO) VALUES ( :1 , :2 , :3 , :4 , :5 , :6 , :7 )
----- Call Stack Trace -----
SQL> select owner,synonym_name from dba_synonyms where synonym_name like 'T_MONITOR_TRAVASO';

OWNER                          SYNONYM_NAME
------------------------------ ------------------------------
IF_APPPRD                      T_MONITOR_TRAVASO
TK_APPPRD                      T_MONITOR_TRAVASO
AN_APPPRD                      T_MONITOR_TRAVASO


++++++++++++++++++++++++++++++++++++++
OBJECT_TYPE
++++++++++++++++++++++++++++++++++++++
COLUMN   OBJECT_NAME ON
FORMAT   a30
select object_name,owner,object_type,count(*) 
from dba_objects
where status like 'INVALID'
group by owner,object_name,object_type;


COLUMN   OBJECT_NAME FORMAT   a30
set pagesize 2222

select owner,object_type,count(*) 
from dba_objects
where status like 'INVALID'
group by owner,object_type
order by 1;

OWNER                          OBJECT_TYPE           COUNT(*)
------------------------------ ------------------- ----------
AN_APPPRD                      PACKAGE BODY                 3
AN_APPPRD                      PROCEDURE                    2
AN_APPPRD                      SYNONYM                      2
AN_IMICAB                      FUNCTION                     1
AN_IMICAB                      PACKAGE BODY                 2
AN_IMICAB                      PROCEDURE                    5
AN_IMICAB                      TRIGGER                      4
AN_IMICAB                      VIEW                        13
DEMBIO1E                       FUNCTION                     1
DEMBIO1E                       PACKAGE BODY                 1
IF_APPPRD                      PROCEDURE                   11
IF_APPPRD                      VIEW                         4


COLUMN   OBJECT_NAME FORMAT 30
select object_name,owner,object_type 
from dba_objects
where status like 'INVALID'
order by 1;

OBJECT_NAME                    OWNER                          OBJECT_TYPE
------------------------------ ------------------------------ -------------------
CARICA_LEGAME_PROD_SOGG        AN_APPPRD                      PROCEDURE
CARICA_LEGAME_STRUM_SOGG       AN_APPPRD                      PROCEDURE
CONFRONTO_BOND                 AN_IMICAB                      VIEW
F_CM_SEGNALAZIONI              AN_IMICAB                      FUNCTION
F_MERCATO_BASE                 DEMBIO1E                       FUNCTION
IFTB607N                       IF_APPPRD                      VIEW
IFTB607N_NEW                   IF_APPPRD                      VIEW
IFTB607N_OLD                   IF_APPPRD                      VIEW
IFTB607N_OLD1                  IF_APPPRD                      VIEW
PKG_LOAD_GESCO                 AN_APPPRD                      PACKAGE BODY
PKG_LOAD_SALES                 AN_APPPRD                      PACKAGE BODY
PKG_MIF_MIGRA                  AN_IMICAB                      PACKAGE BODY
PKG_RICHIESTA                  AN_IMICAB                      PACKAGE BODY
PKG_STORICIZZAZIONE            AN_APPPRD                      PACKAGE BODY
PKG_TEST_CARICA_ANAGELITE      DEMBIO1E                       PACKAGE BODY
PRC_DELTAANTOT                 AN_IMICAB                      PROCEDURE
PRC_POPOLAANTOT                AN_IMICAB                      PROCEDURE
PROC_SR59_DIAGNOSTICA          IF_APPPRD                      PROCEDURE
PROC_SR59_IDENT_SOGGETTO       IF_APPPRD                      PROCEDURE
PROC_SR59_LOC_SOGGETTO         IF_APPPRD                      PROCEDURE
PROC_SR59_LOC_SOGGETTO_OLD     IF_APPPRD                      PROCEDURE
PROC_SR59_RACCORDO_SOGGSAE     IF_APPPRD                      PROCEDURE
PROC_SR59_SOGGETTO             IF_APPPRD                      PROCEDURE
PROC_SR59_SOGGETTO_OLD         IF_APPPRD                      PROCEDURE
PROC_SR59_TMP_CASA_MADRE       IF_APPPRD                      PROCEDURE
PROC_SR59_TMP_CASA_MADRE_OLD   IF_APPPRD                      PROCEDURE
PROC_SR59_TMP_GRP_ECONOMICO    IF_APPPRD                      PROCEDURE
PROC_SR59_TMP_NAZIONI          IF_APPPRD                      PROCEDURE
RIC_POSIZIONI                  AN_IMICAB                      PROCEDURE
TEMP_MERC_MAG_LIQ              AN_APPPRD                      SYNONYM
TEMP_NAZ_REG                   AN_APPPRD                      SYNONYM
TEST                           AN_IMICAB                      PROCEDURE
TRASCO_TITOLI_MPFS             AN_IMICAB                      PROCEDURE
TRG_RICHIESTA_OUTPUT_AZ        AN_IMICAB                      TRIGGER
TRG_RICHIESTA_OUTPUT_CW        AN_IMICAB                      TRIGGER
TRG_RICHIESTA_OUTPUT_OB        AN_IMICAB                      TRIGGER
TRG_T_RICHIESTA_INPUT          AN_IMICAB                      TRIGGER
VW_CHECK_CED_RIMB              AN_IMICAB                      VIEW
VW_CHECK_ISIN_TRANS_DISALL_ANA AN_IMICAB                      VIEW
VW_MONITOR_UIC                 AN_IMICAB                      VIEW
VW_MX_BOND_GENERATOR           AN_IMICAB                      VIEW
VW_RACCORDO_NDG                AN_IMICAB                      VIEW
VW_RICHIESTA_PRODOTTO          AN_IMICAB                      VIEW
VW_RICHIESTA_PRODOTTO_OLD      AN_IMICAB                      VIEW
VW_SF_RATING_FITCH_RK          AN_IMICAB                      VIEW
VW_SIRE_CHECK_ANTOT            AN_IMICAB                      VIEW
VW_SIRE_CHECK_ANTOT2           AN_IMICAB                      VIEW
VW_SIRE_CHECK_ANTOT4           AN_IMICAB                      VIEW
V_CM_SEGNALAZIONI              AN_IMICAB                      VIEW


++++++++++++++++++++++++++++++++++++++
MYNOTE>> GRANT 
++++++++++++++++++++++++++++++++++++++

SYS@orcl > SELECT dbms_metadata.get_ddl('USER','SCOTT') FROM dual;
 
DBMS_METADATA.GET_DDL('USER','SCOTT')
--------------------------------------------------------------------------------
   CREATE USER "SCOTT" IDENTIFIED BY VALUES 'F894844C34402B67'
      DEFAULT TABLESPACE "USERS"
      TEMPORARY TABLESPACE "TEMP"
 
SYS@orcl > SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','SCOTT') from dual;
 
DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','SCOTT')
--------------------------------------------------------------------------------
   GRANT "CONNECT" TO "SCOTT"
   GRANT "RESOURCE" TO "SCOTT"
 
SYS@orcl > SELECT DBMS_METADATA.GET_GRANTED_DDL(OBJECT_GRANT','SCOTT') from dual;
 
DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','SCOTT')
--------------------------------------------------------------------------------
  GRANT SELECT ON "HR"."EMPLOYEES" TO "SCOTT"
 
SYS@orcl > SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','SCOTT') from dual;
 
DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','SCOTT')
--------------------------------------------------------------------------------
  GRANT UNLIMITED TABLESPACE TO "SCOTT"
 
SYS@orcl >  SELECT dbms_metadata.get_ddl('ROLE','RESOURCE') from dual;
 
DBMS_METADATA.GET_DDL('ROLE','RESOURCE')
--------------------------------------------------------------------------------
   CREATE ROLE "RESOURCE"
 
SYS@orcl > SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','RESOURCE') from dual;
 
DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','RESOURCE')
--------------------------------------------------------------------------------
  GRANT CREATE INDEXTYPE TO "RESOURCE"
  GRANT CREATE OPERATOR TO "RESOURCE"
  GRANT CREATE TYPE TO "RESOURCE"
  GRANT CREATE TRIGGER TO "RESOURCE"
  GRANT CREATE PROCEDURE TO "RESOURCE"
  GRANT CREATE SEQUENCE TO "RESOURCE"
  GRANT CREATE CLUSTER TO "RESOURCE"
  
  
  
  
##
### Grid 11r2
##

/sw/grid/log/rr*/crsd
/sw/grid/log/rr*/cssd



++++++++++++++++++++++++++++++++++++++
MYNOTE>> LOCK
++++++++++++++++++++++++++++++++++++++

 update gp_appprd.info_task_sched set status='IDLE' where nome_task='BAPP_EURG1_SUP' and status='RUNNING';



SQL> select sid,event from v$session where sid=825;

       SID EVENT
---------- ----------------------------------------------------------------
       825 enq: TX - row lock contention



-- da fare su ogni nodo RAC--
select object_name, s.sid, s.serial#, p.spid 
from v$locked_object l, dba_objects o, v$session s, v$process p
where l.object_id = o.object_id and l.session_id = s.sid and s.paddr = p.addr and object_name like upper('info_task_sched');






++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++
MYNOTE>> RECUPERO SPAZIO
++++++++++++++++++++++++++++++++++++++

Spazio recuperabile secondo l’ASA se eseguiamo gli shrink suggeriti:
SQL>   select tablespace_name, trunc(sum(reclaimable_space)/1024/1024/1024) GB_RECLAIMABLE
from table(dbms_space.asa_recommendations('FALSE', 'FALSE', 'FALSE')) group by tablespace_name;15:19:35   2

 

TABLESPACE_N GB_RECLAIMABLE
GOLD0001D                39                     circa il 13%
GOLD0001I                14                       circa il 7% 

 

Per vedere i singoli suggerimenti dell’ASA:
  select tablespace_name,segment_name,allocated_space,used_space,reclaimable_space, recommendations
from table(dbms_space.asa_recommendations('FALSE', 'FALSE', 'FALSE'));

 

 

Attuale spazio sui tbs:
 TABLESPACE            Totalspace(MB) Used (MB)        Freespace(MB)      %Used      %Free
GOLD0001D                         335.040         282.338                   52.702      84.27      15.73
GOLD0001I                          212.156         199.489                   12.667      94.03       5.97

